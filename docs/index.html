<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta
name="viewport"
content="width=device-width, initial-scale=1.0"
>
<title>Selecting Whole Words</title>
<link rel="stylesheet" href="../public/styles.css">
<link rel="stylesheet" href="../public/media-queries.css">
<link rel="stylesheet" href="../public/prism/prism.css">

<script defer src="../public/prism/prism.js"></script>
<script defer src="../public/storage.js"></script>
<script defer src="../public/script.js"></script>
</head>

<body>
<main id="content">
<header>
<a href="https://MERNCraft.github.io"><img src="../public/svg/home.svg" alt="home"></a>
<h1>Selecting Whole Words</h1>
<h3>with window.getSelection() and Intl.Segmenter</h3>
<h4>November 2025</h4>
</header>
<nav
  id="content-header"
  aria-labelledby="content-header"
>
  <button type="button" class="previous" disabled>
    <img src="../public/svg/prev.svg" alt="previous" draggable="false">
  </button>
  <span class="previous-name"></span>
  <span class="spacer"></span>
  <button type="button" class="next">
    <img src="../public/svg/next.svg" alt="next" draggable="false">
  </button>
  <span class="next-name"></span>
</nav>

<!-- The Selection Object -->
<section id="the-selection-object" aria-labelledby="the-selection-object" data-item="The Selection Object">
<h2>
<a href="#the-selection-object">The Selection Object</a>
</h2>
<p>I‚Äôll start by introducing two leading characters in the story that
will unfold: the Selection and the Range object.</p>
<h3 id="the-selection-object">The Selection object</h3>
<p>From the moment you launch a web page, the browser window has a <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Selection">Selection</a>
object, which JavaScript gives you access to. The official way to talk
to it is as <code>window.getSelection()</code>, but throughout this
tutorial, I will be assigning this to a variable, so you can call it
<code>selection</code>, for short.</p>
<p>When you drag to select an image or some text in a web page, the
<code>selection</code> updates internally, to reflect whatever is
currently selected. When you select text, the plain text version of what
you selected is available through <code>selection.toString()</code>.
Indeed, if you just <code>console.log(selection)</code>, what you will
see is a string of plain text (or perhaps an empty string, if no text is
selected.)</p>
<h3 id="the-range-object">The Range object</h3>
<p>Each selected section is in fact stored in a <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range">Range</a>
object. In browsers that support multiple Range objects, there can be
many separate selected areas on the page.</p>
<h3 id="selective-vision">Selective Vision?</h3>
<p>However, the Selection object does not have access to everything that
you see on a page. For example, <code>selection</code> has no access
to:</p>
<ul>
<li>Pseudo-elements, like <code>::before</code> or <code>::after</code>,
or any <code>::marker</code> for a list item</li>
<li>The text of <code>&lt;input&gt;</code> elements,
<code>&lt;select&gt;</code> elements and <code>&lt;textarea&gt;</code>
elements</li>
<li>Any elements with a CSS styling of
<code>user-select: none</code>.</li>
</ul>
<p>The selection <strong>can</strong> however contain formatting tags
and their content, like
<code>This chunk with &lt;i&gt;italic&lt;/i&gt; text.</code>
<strong>Note</strong> that <code>selection.toString()</code> will show
only plain text, even if the <code>selection</code> does in fact hold
formatted text.</p>
<h3 id="see-for-yourself">See for yourself</h3>
<p>To get an idea of what <code>selection</code> can and cannot see,
click and drag to make some selections in the demo below, and watch how
the text in the grey feedback zone changes.</p>
<iframe id="selection-and-range" title="Selection and Range" width="480" height="360" src="https://merncraft.github.io/SelectionAndRange/">
</iframe>
<p>Try selecting different parts of the page:</p>
<ul>
<li>The text at the top</li>
<li>The emoji</li>
<li>Both lines of text together</li>
<li>The words ‚ÄúDIV‚Äù</li>
<li>The image</li>
<li>The text in italics‚Ä¶ and some text to either side of it</li>
<li>The text in the input field</li>
<li>The text in the grey feedback zone that displays what the Selection
object is aware of</li>
<li>The entire contents of the page</li>
</ul>
<p>Also, try simply clicking somewhere in the text without making any
selection.</p>
<p>You can find the full</p>
<details class="solution">
<summary>
Try this at home
</summary>
<p>To create the same demo on your own computer, you can clone the <a
href="https://github.com/MERNCraft/SelectionAndRange">GitHub
repository</a>, or follow the instructions below.</p>
<ol type="1">
<li>Greate a file called <code>index.html</code></li>
<li>Copy and paste the HTML shown below into it</li>
<li>Open the file in your Browser</li>
</ol>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;title&gt;getSelection&lt;/title&gt;
  &lt;style&gt;
    pre {
      background-color: #ccc;
      min-height: 1em;
    }
    div::before {
      content: "DIV &gt;&gt;&gt;"
    }
    div::after {
      content: "&lt;&lt;&lt; DIV"
    }
    #feedback {
      -webkit-user-select: none;
      user-select: none;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p id="one"&gt;Click and drag       to make a selection üëçüèº&lt;/p&gt;
  &lt;p id="two"&gt;Your selection can <i>start</i> on one line and <i>end</i> on another.&lt;/p&gt;
  &lt;div&gt;
    &lt;img src="https://picsum.photos/32/32" alt="picsum image"&gt;
  &lt;/div&gt;
  &lt;input type="text" placeholder="text input"&gt;
  &lt;pre id="feedback"&gt;&lt;/pre&gt;

  &lt;script&gt;
    const feedback = document.getElementById("feedback")
    document.body.addEventListener("mousemove", showSelection)
    document.body.addEventListener("mouseup", showSelection)

    function showSelection() {
      const selection = window.getSelection()
      if (!selection.rangeCount) {
        feedback.innerText = "selection.rangeCount: 0"
        return
      }

      const range = selection.getRangeAt(0)

      const start = range.startContainer
      const startName = start.nodeName
      let startParent = range.startContainer.parentElement
      let id = startParent.id
      startParent = startParent.tagName.toLowerCase()
                  + (id ? `#${id}` : "")

      const end = range.endContainer
      const endName = end.nodeName
      let endParent = range.endContainer.parentElement
      id = endParent.id
      endParent = endParent.tagName.toLowerCase()
                + (id ? `#${id}` : "")
      
      feedback.innerText = `'${selection}'
range.startContainer.nodeName:      ${startName}
range.startContainer.parentElement: ${startParent}
range.startOffset:                  ${range.startOffset}

range.endContainer.nodeName:        ${endName}
range.endContainer.parentElement:   ${endParent}
range.endOffset:                    ${range.endOffset}`
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>
<h3 id="observing-the-selection-and-its-range-object">Observing the
Selection and its Range object</h3>
<p>The window‚Äôs Selection object is created as soon as the page loads.
As you can see in the script of your HTML page, you can get a pointer to
it using <code>window.getSelection()</code>.</p>
<p>If there is something selected on the page, the Selection object will
have at least one Range object. But as the next image shows, when the
page is first loaded, before the first click, nothing is selected, and
the selection has no Range objects to share. Its <code>rangeCount</code>
is initially zero.</p>
<pre class="language-js line-numbers" data-start="37"><code class="language-js line-numbers">const selection = window.getSelection()
if (!selection.rangeCount) {
  feedback.innerText = "selection.rangeCount: 0"
  return
}</code></pre>
<figure>
<img src="images/just_loaded.webp" alt="Page just loaded" />
<figcaption aria-hidden="true">Page just loaded</figcaption>
</figure>
<h3 id="best-supporting-roles">Best Supporting Roles‚Ä¶</h3>
<p>If you double-click on the word ‚ÄòClick‚Äô or click and drag to select
it, you‚Äôll see in the grey feedback zone that a Range object is created.
It has four properties that you will be using a lot:</p>
<ul>
<li><code>startContainer</code></li>
<li><code>startOffset</code></li>
<li><code>endContainer</code></li>
<li><code>endOffset</code></li>
</ul>
<figure>
<img src="images/click_selected.webp"
alt="Selecting the word ‚ÄòClick‚Äô" />
<figcaption aria-hidden="true">Selecting the word ‚ÄòClick‚Äô</figcaption>
</figure>
<p>You might have two surprises here. First, the range mentions <em>two
container</em> objects: <code>startContainer</code> and
<code>endContainer</code>, although you know that the word ‚ÄòClick‚Äô is
entirely contained in one <code>&lt;p&gt;</code> element. Second, both
the <em>nodeName</em> of both the <code>startContainer</code> and the
<code>endContainer</code> is given as <code>#text</code>, not as
<code>&lt;p&gt;</code>. The element you created as
<code>&lt;p id="one"&gt;</code> is shown as the
<code>range.startContainer.parentElement</code>.</p>
<p>You can see the <code>parentElement</code>‚Äôs full title and more
details of the range object, if you place a breakpoint in the
Debugger:</p>
<figure>
<img src="images/breakpoint.webp"
alt="Add a breakpoint after the range variable is set‚Ä¶" />
<figcaption aria-hidden="true">Add a breakpoint after the range variable
is set‚Ä¶</figcaption>
</figure>
<figure>
<img src="images/debugging_range.webp"
alt="‚Ä¶then observe the range object in the Debugger" />
<figcaption aria-hidden="true">‚Ä¶then observe the range object in the
Debugger</figcaption>
</figure>
<h3 id="whats-a-text-node">What‚Äôs a #text node?</h3>
<p>An HTML element, like a <code>&lt;p&gt;</code> element, can contain
more than just text. It can also contain inline content elements like
<code>&lt;img&gt;</code>, <code>&lt;input&gt;</code> or
<code>&lt;select&gt;</code>, or inline formatting elements like
<code>&lt;i&gt;</code> and <code>&lt;b&gt;</code>. Everything between
these inline elements, and all text inside them, is treated as a
<code>text node</code>. Even the gaps between HTML elements in the HTML
page are considered to be text nodes. Here‚Äôs an example. All the
highlighted characters in the HTML code below are in text nodes,
including the invisible spaces and carriage returns.</p>
<pre class="language-html"><code class="language-html"><i>&lt;p&gt;<u>‚Üµ
  </u>&lt;span&gt;<u>text node in a child span</u>&lt;/span&gt;<u>‚Üµ
  text node in the top-level paragraph‚Üµ</u>
&lt;/p&gt;</i></code></pre>
<details class="alert" open>
<summary>
White space
</summary>
<p>By default, all consecutive white space in text nodes is collapsed
into a single space (<code></code>) character, so you may not be aware
of how much white space there actually is. But you‚Äôll need to pay
attention: soon you‚Äôll be having to count every last white space
character, if you want to get your text selection tool to work well.</p>
<p>Notice, for example, how this line in your HTML file contains many
spaces between ‚Äúdrag‚Äù and ‚Äúto‚Äù‚Ä¶</p>
<pre class="language-html line-numbers" data-start="72"><code class="language-html line-numbers">&lt;p id="one"&gt;Click and drag       to make a selection üëçüèº&lt;/p&gt;</code></pre>
<p>‚Ä¶ but this line in the rendered page shows only one:<br><br></p>
<figure>
<img src="images/one_space.webp"
alt="Only one space rendered between ‚Äúdrag‚Äù and ‚Äúto‚Äù" />
<figcaption aria-hidden="true">Only one space rendered between ‚Äúdrag‚Äù
and ‚Äúto‚Äù</figcaption>
</figure>
</details>
<h3 id="startoffset-and-endoffset">startOffset and endOffset</h3>
<p>When the word ‚ÄòClick‚Äô is selected, the <code>startOffset</code> is
<code>0</code> while the <code>endOffset</code> is set to
<code>5</code>.</p>
<p>You should be used to JavaScript counting from 0. Here, it is saying
that your selection starts when there are 0 characters to the left, and
it ends after the 5-letter word ‚ÄòClick‚Äô, when there are 5 characters to
the left.</p>
<p>On the page, the distance between the start of the letter ‚Äúg‚Äù in
‚Äúdrag‚Äù and the end of the letter ‚Äút‚Äù in ‚Äútwo‚Äù, looks like it should give
an offset difference of <code>3</code>, but the <code>range</code>
object is looking at the source HTML, and it keeps a different
score:</p>
<figure>
<img src="images/22-13.webp"
alt="One visual space can be many HTML white space characterss" />
<figcaption aria-hidden="true">One visual space can be many HTML white
space characterss</figcaption>
</figure>
<figure>
<img src="images/emoji_selected.webp"
alt="An emoji can count as several characters" />
<figcaption aria-hidden="true">An emoji can count as several
characters</figcaption>
</figure>
<figure>
<img src="images/image_selected.webp"
alt="The alt text of an image as seen by Selection" />
<figcaption aria-hidden="true">The alt text of an image as seen by
Selection</figcaption>
</figure>
<figure>
<img src="images/two_lines.webp"
alt="When startContainer and endContainer are different" />
<figcaption aria-hidden="true">When startContainer and endContainer are
different</figcaption>
</figure>
<figure>
<img src="images/start_in_i_tag.webp"
alt="Container.parentElements of different types" />
<figcaption aria-hidden="true">Container.parentElements of different
types</figcaption>
</figure>
<figure>
<img src="images/input_selected.webp"
alt="Text that can‚Äôt be selected by Selection" />
<figcaption aria-hidden="true">Text that can‚Äôt be selected by
Selection</figcaption>
</figure>
<figure>
<img src="images/all_selected.webp"
alt="Everything on the page is ‚Äúselected‚Äù‚Ä¶ or is it?" />
<figcaption aria-hidden="true">Everything on the page is ‚Äúselected‚Äù‚Ä¶ or
is it?</figcaption>
</figure>
<figure>
<img src="images/all_deselected.webp"
alt="A click to the right of the input field: no text selected" />
<figcaption aria-hidden="true">A click to the right of the input field:
no text selected</figcaption>
</figure>
<figure>
<img src="images/invisible_caret.webp"
alt="A click collapses the Selection to an invisible caret" />
<figcaption aria-hidden="true">A click collapses the Selection to an
invisible caret</figcaption>
</figure>
</section>
<section id="intro" aria-labelledby="intro" data-item="Introduction">
<h2>
<a href="#intro">Introduction</a>
</h2>
<iframe id="demo" title="demo" width="600" height="300" src="https://merncraft.github.io/SplitSpansDemo/">
</iframe>
<h3 id="whats-in-store-for-you">What‚Äôs in Store for You</h3>
<h4 id="part-1-selection">Part 1: Selection</h4>
<ol type="1">
<li>window.getSelection()</li>
</ol>
<ul>
<li>What it returns (a Selection object)</li>
<li>Multiple ranges? (selection.rangeCount)</li>
<li>Basic usage examples (toString(), getRangeAt(0))</li>
</ul>
<ol start="2" type="1">
<li>The Range object</li>
</ol>
<ul>
<li>Properties: startContainer, startOffset, endContainer, endOffset,
commonAncestorContainer</li>
<li>Methods: selectNode, selectNodeContents, setStart, setEnd,
cloneRange</li>
<li>Why you often want a Range instead of just the selection string</li>
</ul>
<ol start="3" type="1">
<li>Text nodes vs element nodes</li>
</ol>
<ul>
<li>What a text node is (nodeType === 3)</li>
<li>How inline elements affect selections (<code>&lt;b&gt;</code>,
<code>&lt;i&gt;</code>, <code>&lt;span&gt;</code>)</li>
<li>Why startContainer can be a text node or an element (Safari
quirk)</li>
<li>Using childNodes to inspect the DOM structure</li>
</ul>
<ol start="4" type="1">
<li>Selection offsets</li>
</ol>
<ul>
<li>Offsets relative to the container (text node vs element)</li>
<li>Why startOffset and endOffset may not correspond to visible
characters exactly (whitespace, hidden nodes, zero-length nodes)</li>
<li>Common mistakes when computing offsets directly
<ul>
<li>Treating offsets as global visible positions</li>
<li>Assuming containers are always text nodes</li>
<li>Forgetting that whitespace rules affect selectable characters</li>
<li>Not accounting for invisible/empty text nodes</li>
<li>Treating endOffset as inclusive</li>
<li>Misunderstanding UTF-16 vs grapheme clusters</li>
<li>Using textContent.length as if spans were one node</li>
<li>Misinterpreting backwards selections</li>
<li>Mutating the DOM before preserving Range info</li>
</ul></li>
</ul>
<ol start="5" type="1">
<li>Browser differences</li>
</ol>
<ul>
<li>Safari quirks:</li>
<li>startContainer may be in a previous element‚Äôs text node</li>
<li>Selections may ‚Äúsnap‚Äù across inline boundaries</li>
<li>Chrome/Firefox generally behave consistently</li>
<li>Implications for algorithms that rely on DOM offsets</li>
</ul>
<ol start="6" type="1">
<li>Clamping / normalizing selections</li>
</ol>
<ul>
<li>Concept: adjusting startContainer and endContainer to the
‚Äúfirst/last selectable text node‚Äù in the intended range</li>
<li>Why this is needed before doing any text manipulation or
word-boundary expansion</li>
<li>Example: ‚ÄúSnap selection start to 0 offset of first text node inside
element‚Äù</li>
</ul>
<ol start="7" type="1">
<li>Traversing selected text</li>
</ol>
<ul>
<li>Why you need to iterate all text nodes between startContainer and
endContainer</li>
<li>Introduce TreeWalker or NodeIterator for walking the DOM</li>
<li>Differences between childNodes iteration vs TreeWalker (nested
inline elements)</li>
</ul>
<ol start="9" type="1">
<li>Handling whitespace white-space CSS affects what is visually
selectable</li>
</ol>
<ul>
<li>pre-wrap vs normal vs nowrap</li>
<li>How this affects offset calculations</li>
<li>Note: pseudo-elements (::before, ::after) are ignored because they
aren‚Äôt selectable</li>
</ul>
<ol start="9" type="1">
<li>Edge cases and best practices</li>
</ol>
<ul>
<li>Empty elements or elements with no text nodes</li>
<li>Nested inline elements (<b><i>text</i></b>)</li>
<li>Collapsed nodes or nodes with only whitespace</li>
<li>Using Range.compareBoundaryPoints to detect containment</li>
</ul>
<ol start="10" type="1">
<li>Topics to explore further</li>
</ol>
<ul>
<li>Using range.getClientRects() for visual selection bounds</li>
<li>Multi-range selections (rare, but good to mention)</li>
<li>How selection APIs interact with contenteditable areas</li>
<li>Selection normalization strategies from popular editors
(ProseMirror, Slate)</li>
</ul>
<h4 id="part-2-detecting-word-boundaries">Part 2: Detecting word
boundaries</h4>
<ol type="1">
<li>How browser understand word boundaries</li>
<li>Intl.Segmenter basics</li>
<li>Mapping segmenter offsets back to the DOM</li>
<li>Working no-break characters</li>
<li>Language-specific rules for punctuation</li>
<li>Boundaries around inline formatting</li>
<li>Identifying blocks that should not be broken</li>
<li>Words that span DOM nodes, for whatever reason</li>
<li>Special case: Speaker change em-dash for subtitles</li>
</ol>
<h4 id="part-3-splitting-and-merging-elements">Part 3: Splitting and
merging elements</h4>
<ol type="1">
<li>How Range mutations work</li>
<li>Splitting text nodes and inline structures</li>
<li>Extracting content with extractContents()</li>
<li>Safe merging: style checks, tagName checks</li>
<li>Wrapping selection in spans</li>
<li>Avoiding nested span hell</li>
<li>Removing/redesigning wrappers</li>
<li>Adding a class to new spans</li>
</ol>
<h4 id="mini-projects">Mini Projects</h4>
<ul>
<li><p>Project 1: Basic selection Single text node, no formatting Goal:
get selected text and offsets</p></li>
<li><p>Project 2: Inline formatting <code>&lt;b&gt;</code> or
<code>&lt;i&gt;</code> inside text Goal: understand startContainer and
endContainer with nested tags</p></li>
<li><p>Project 3: Multi-span selection Two adjacent
<code>&lt;span&gt;</code> elements Goal: see how selection crosses
elements, offsets are computed</p></li>
<li><p>Project 4: Whitespace handling Show white-space: pre-wrap vs
normal Goal: see which characters are actually selectable</p></li>
</ul>
<p>Project 5: Safari quirk Cross-span startContainer issue Goal:
understand why clamping/normalization is needed</p>
<ul>
<li><p>Project 6: Introduction to TreeWalker Walk selected text nodes,
accumulate text Goal: show how to reliably collect selected
text</p></li>
<li><p>Project 7: Selection clamping Normalize selection start/end to
first/last text node Goal: ready for word-boundary expansion in Part
2</p></li>
</ul>
<hr />
<ul>
<li>Whole-word expansion</li>
<li>Splitting text out of existing spans</li>
<li>Splitting <code>&lt;b&gt;</code>, <code>&lt;i&gt;</code>, etc. at
selection boundaries</li>
<li>Creating a new span exactly around the selection</li>
<li>Merging neighboring spans when appropriate</li>
<li>Normalizing Safari‚Äôs misaligned selection containers</li>
<li>DOM text walking</li>
<li>Range manipulation</li>
</ul>
<details class="tldr">
<summary>
TL;DR: My personal use case
</summary>
<p>I teach English as a foreign language to adults. I have friends who
teach their own native languages, to adults and to children. A big
question that we have is: ‚ÄúHow to make learners want to spend time
practising their new language?‚Äù One way is to get them to watch films in
their target language. Or perhaps better yet (and free): get them to
watch short YouTube videos on subjects that interest them.</p>
<h3 id="youtube-auto-generated-transcripts">YouTube auto-generated
transcripts</h3>
<p>Many YouTube videos provide subtitles, and an interactive transcript.
You can show the subtitles by clicking on the
<code>Subtitles/closed caption</code> button in the YouTube toolbar, and
you can show the transcript by ‚Ä¶</p>
<ul>
<li>Clicking on the <code>more...</code> button in the summary</li>
<li>Scrolling to near the end to find the <code>Show Transcript</code>
button</li>
<li>Making your web page wide enough to see the interactive transcript
to the side of your video.</li>
</ul>
<p>But the YouTube website is design for YouTube to optimize revenue.
Our language students don‚Äôt need all the ads and links and extra
content. They really just want a good video to watch, and help with
understanding what is being said.</p>
<p>Auto-generated subtitles can be wildly wrong and confusing. Even when
they are accurate, the timing of the subtitles can be awkward and
imprecise. A subtitle might contain speech both before and after a scene
change, and it might be too long to be comfortable. The transcript is
broken up into timed chunks that might not correspond to actual
sentences.</p>
<h3 id="doing-it-better">Doing it better</h3>
<p>I wanted to create something more like the system provided by <a
href="https://www.ted.com/talks/joshua_foer_feats_of_memory_anyone_can_do/transcript">ted.com</a>,
which:</p>
<ul>
<li>Shows the transcript in natural paragraphs</li>
<li>Uses a separate span for each natural break in the speech</li>
<li>Provides transcripts created by humans and translated by humans into
many different languages.</li>
</ul>
<p>I also wanted to add a feature that allows language learners to play
a particular phrase or sentence in a loop, perhaps a little more slowly,
so that they have the chance to hear how the speaker actually pronounces
the words.</p>
<p>A subtitle might say: ‚ÄúIt‚Äôs going to be good!‚Äù but the speaker might
make a sound like ‚ÄúSgonnbegooh!‚Äù It can take a learner a little time to
get used to the shortcuts native speakers make, that other native
speakers can easily understand.</p>
<p>So, before releasing my ‚ÄúLearn a language through YouTube‚Äù app, I had
to make myself a tool that would allow me to:</p>
<ul>
<li>Paste a YouTube URL</li>
<li>Automatically download the transcript</li>
<li>Automatically download the audio file, and generate a waveform
graphic from it, so I could easily see where sounds began and ended</li>
<li>Edit the text of the auto-generated transcript</li>
<li>Divide the transcript into natural segments for subtitles</li>
<li>Set the start and end times of each subtitle precisely</li>
<li>Allow a translator to follow the video and the original subtitles
while making a translation</li>
<li>Provide the translator with some flexibility about subtitle timing,
as different languages give the same information in a different
order.</li>
<li>Export the subtitles in the standard SRT format, to be used by my
‚ÄúLearn a language through YouTube‚Äù app.</li>
</ul>
<p>Hence the need to split and merge the text of HTML spans, as
described in this tutorial.</p>
<p>You can find the Subtitle Optimizer tool <a href="">here</a>, and the
‚ÄúLearn a language through YouTube‚Äù app <a
href="https://stv.jazyx.com">here</a>.</p>
<blockquote>
<h3 id="fun-fact">Fun Fact</h3>
<p>One advantage of watching YouTube videos embedded in third-party site
is that <strong>the videos are never interrupted by ads</strong>.</p>
<p>And yes, I contact the content creators whose videos I link to, to
make sure that they are happy that their work is used in this
educational manner, even if it means that they don‚Äôt earn any ad revenue
from it.</p>
</blockquote>
</details>
</section>

<div class="spacer"></div>
<footer id="content-footer">
<button type="button" class="previous" disabled>
  <img src="../public/svg/prev.svg" alt="prev" draggable="false">
</button>
<span class="previous-name"></span>
<span class="spacer"></span>
<button type="button" class="next">
  <img src="../public/svg/next.svg" alt="next" draggable="false">
</button>
<span class="next-name"></span>
</footer>
</main>

<nav
id="menu"
aria-labelledby="menu"
class="open"
>
<div class="theme">
  <label
  title="Dark"
  >
  <img src="../public/svg/dark.svg" alt="dark">
  <input
  type="radio"
  name="theme"
  id="theme-dark"
  checked
  >
  </label>
  <label
  title="Light"
  >
  <img src="../public/svg/light.svg" alt="light">
  <input
  type="radio"
  name="theme"
  id="theme-light"
  >
  </label>
  </div>
  <div class="paging">
  <label
  title="Split into sections"
  >
  <img src="../public/svg/pages.svg" alt="pages">
  <input
  type="radio"
  name="paging"
  id="pages"
  checked
  >
  </label>
  <label
  title="Show as a single page"
  >
  <img src="../public/svg/scroll.svg" alt="scroll">
  <input
  type="radio"
  name="paging"
  id="scroll"
  >
  </label>
  </div>
<img src="../public/svg/hamburger.svg" alt="menu" id="menu-icon">

<ul id="menu-items">
</ul>
<div id="repo">
<a
href="https://github.com/MERNCraft/SplitSpans/issues/new"
>
Feedback
</a>

<a
class="repo"
href="https://github.com/MERNCraft/SplitSpans"
>
<img src="../public/svg/github.svg" alt="github logo">
<span>GitHub repository</span>
</a>
</div>
</nav>
</body>
</html>