<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta
name="viewport"
content="width=device-width, initial-scale=1.0"
>
<title>Selecting Whole Words</title>
<link rel="stylesheet" href="../public/styles.css">
<link rel="stylesheet" href="../public/media-queries.css">
<link rel="stylesheet" href="../public/prism/prism.css">

<script defer src="../public/prism/prism.js"></script>
<script defer src="../public/storage.js"></script>
<script defer src="../public/script.js"></script>
</head>

<body>
<main id="content">
<header>
<a href="https://MERNCraft.github.io"><img src="../public/svg/home.svg" alt="home"></a>
<h1>Selecting Whole Words</h1>
<h3>with window.getSelection() and Intl.Segmenter</h3>
<h4>November 2025</h4>
</header>
<nav
  id="content-header"
  aria-labelledby="content-header"
>
  <button type="button" class="previous" disabled>
    <img src="../public/svg/prev.svg" alt="previous" draggable="false">
  </button>
  <span class="previous-name"></span>
  <span class="spacer"></span>
  <button type="button" class="next">
    <img src="../public/svg/next.svg" alt="next" draggable="false">
  </button>
  <span class="next-name"></span>
</nav>

<!-- The Selection Object -->
<section id="the-selection-object" aria-labelledby="the-selection-object" data-item="The Selection Object">
<h2>
<a href="#the-selection-object">The Selection Object</a>
</h2>
<p>Before you can master a field of knowledge, you need to be able
create clear mental images, which are not too different from the reality
that you need to deal with. One good way to do this is with hands-on
manipulation, where you can get immediate feedback on the effect of the
changes that you make.</p>
<p>I‚Äôll start by introducing two leading characters in the story that
will unfold: the <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Selection">Selection</a>
and the <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range">Range</a>
object. And then I‚Äôll show you the interplay between them and their
supporting cast: <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startContainer">range.startContainer</a>
with its companion <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startOffset">range.startOffset</a>,
together with <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endContainer">range.endContainer</a>
with its companion <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endOffset">range.endOffset</a>.</p>
<h3 id="the-selection-object">The Selection object</h3>
<p>From the moment you launch a web page, the browser window has a <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Selection">Selection</a>
object, which JavaScript gives you access to. The official way to talk
to it is as <code>window.getSelection()</code>, but throughout this
tutorial, I will be assigning this to a variable, so you can call it
<code>selection</code>, for short.</p>
<p>When you drag to select an image or some text in a web page, the
<code>selection</code> updates internally, to reflect whatever is
currently selected. When you select text, the plain text version of what
you selected is available through <code>selection.toString()</code>.
Indeed, if you just <code>console.log(selection)</code>, what you will
see is a string of plain text (or perhaps an empty string, if no text is
selected.)</p>
<p>This is what is showen at the top of grey feedback section</p>
<h3 id="the-range-object">The Range object</h3>
<p>Each selected section is in fact stored in a <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range">Range</a>
object. In browsers that support multiple Range objects, there can be
many separate selected areas on the page.</p>
<h3 id="selective-vision">Selective Vision?</h3>
<p>However, the Selection object does not have access to everything that
you see on a page. For example, <code>selection</code> has no access
to:</p>
<ul>
<li>Pseudo-elements, like <code>::before</code> or <code>::after</code>,
or any <code>::marker</code> for a list item</li>
<li>The text of <code>&lt;input&gt;</code> elements,
<code>&lt;select&gt;</code> elements and <code>&lt;textarea&gt;</code>
elements</li>
<li>Any elements with a CSS styling of
<code>user-select: none</code>.</li>
</ul>
<p>The selection <strong>can</strong> however contain formatting tags
and their content, like
<code>This chunk with &lt;i&gt;italic&lt;/i&gt; text.</code>
<strong>Note</strong> that <code>selection.toString()</code> will show
only plain text, even if the <code>selection</code> does in fact hold
formatted text.</p>
<h3 id="see-for-yourself">See for yourself</h3>
<p>To get an idea of what <code>selection</code> can and cannot see,
click and drag to make some selections in the demo below, and watch how
the text in the grey feedback zone changes.</p>
<iframe id="selection-and-range" title="Selection and Range" width="480" height="480" src="https://merncraft.github.io/SelectionAndRange/">
</iframe>
<p>Try selecting different parts of the page:</p>
<ul>
<li>The text at the top</li>
<li>The emoji</li>
<li>Both lines of text together</li>
<li>The words ‚ÄúDIV‚Äù</li>
<li>The image</li>
<li>The text in italics‚Ä¶ and some text to either side of it</li>
<li>The text in the input field</li>
<li>The text in the grey feedback zone that displays what the Selection
object is aware of</li>
<li>The entire contents of the page</li>
</ul>
<p>Also, try simply clicking somewhere in the text without making any
selection.</p>
<details class="tip" open>
<summary>
Keep the demo accessible for testing
</summary>
<p>You might like to open this page in a second browser window, so that
you can keep this demo available side-by-side for testing as you scroll
down in this window to read the rest of the tutorial.</p>
<p>Alternatively, you can create your own version of the demo and open
it in a separate window.</p>
<p>You can find the full script of this demo in the <em>Try This at
Home</em> section below. I‚Äôll be quoting extracts of the script in what
follows, so that you can see how the code works.</p>
</details>
<details class="solution">
<summary>
Try This at Home
</summary>
<p>To create the same demo on your own computer, you can clone the <a
href="https://github.com/MERNCraft/SelectionAndRange">GitHub
repository</a>, or follow the instructions below.</p>
<ol type="1">
<li>Greate a file called <code>index.html</code></li>
<li>Copy and paste the HTML shown below into it</li>
<li>Open the file in your Browser</li>
</ol>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;title&gt;getSelection&lt;/title&gt;
  &lt;style&gt;
    body {
      color: #ddd;
      background-color: #111;
    }
    div#image {
      text-align: center;
      img {
        vertical-align: middle;
      }
      &::before {
        content: "::before\00a0\00a0";
      }
      &::after {
        content: "\00a0\00a0::after"
      }
    }
    input {
      margin: 1em 0;
      width: 100%;
    }
    pre {
      background-color: #333;
      min-height: 1em;
      margin-top: 0;
      white-space: pre-wrap;
    }
    pre,
    .feedback {
      -webkit-user-select: none;
      user-select: none;

      & span {
        display: inline-block;
        font-family: monospace;
        text-decoration: underline;
        width: 100%;
        text-align: center;
      }
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p id="one"&gt;Click and drag       to make a selection üëçüèº&lt;/p&gt;
  &lt;p id="two"&gt;Your selection can <i>start</i> on one line and <i>end</i> on another.&lt;/p&gt;
  &lt;div id="image"&gt;
    &lt;img
      src="https://picsum.photos/48/48"
      alt="random image from https://picsum.photos/48/48"
    &gt;
  &lt;/div&gt;
  &lt;input type="text" placeholder="text input"&gt;
  &lt;div class="feedback"&gt;
    &lt;span&gt;selection.toString()&lt;/span&gt;
    &lt;pre id="selection"&gt;&lt;/pre&gt;
  &lt;/div&gt;
  &lt;div class="feedback"&gt;
    &lt;span&gt;selection.getRangeAt(0)&lt;/span&gt;
    &lt;pre id="range"&gt;&lt;/pre&gt;
  &lt;/div&gt;

  &lt;script&gt;
    let ii = 0
    const selectionP = document.getElementById("selection")
    const rangeP = document.getElementById("range")

    const selection = window.getSelection()

    setInterval(showSelection, 100)

    function showSelection() {
      if (!selection.rangeCount) {
        selectionP.innerText = "selection.rangeCount: 0"
        rangeP.innerText = ""
        return
      }

      const range = selection.getRangeAt(0)

      const start = range.startContainer
      const startName = start.nodeName
      let startParent = range.startContainer.parentElement
      let id = startParent.id
      startParent = startParent.tagName.toLowerCase()
                  + (id ? `#${id}` : "")

      const end = range.endContainer
      const endName = end.nodeName
      let endParent = range.endContainer.parentElement
      id = endParent.id
      endParent = endParent.tagName.toLowerCase()
                + (id ? `#${id}` : "")

      selectionP.innerText = selection

      rangeP.innerText =
`range.startContainer.nodeName:      ${startName}
range.startContainer.parentElement: ${startParent}
range.startOffset:                  ${range.startOffset}

range.endContainer.nodeName:        ${endName}
range.endContainer.parentElement:   ${endParent}
range.endOffset:                    ${range.endOffset}`
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>
<h3 id="observing-the-selection-and-its-range-object">Observing the
Selection and its Range object</h3>
<p>The window‚Äôs Selection object is created as soon as the page loads.
As you can see in the script in the Try This at Home section, you can
get a pointer to it using <code>window.getSelection()</code>.</p>
<p>If there is something selected on the page, the Selection object will
have at least one Range object. The number of Range objects currently in
use is given by <code>selection.rangeCount</code>.</p>
<p>But as the next script extract and image show, when the page is first
loaded, before the first click, nothing is selected, and the selection
has no Range objects to share. Its <code>rangeCount</code> is initially
zero.</p>
<pre class="language-js line-numbers" data-start="71"><code class="language-js line-numbers"><b>    const selection = window.getSelection()</b>

<i>    setInterval(showSelection, 100)

    function showSelection() {</i>
<b>      if (!selection.rangeCount) {
        selectionP.innerText = "selection.rangeCount: 0"</b><i>
        rangeP.innerText = ""
        return
      }</i></code></pre>
<pre class="skip"><code class="skip">...</code></pre>
<pre class="language-js line-numbers" data-start="108"><code class="language-js line-numbers">    <i>}</i></code></pre>
<figure>
<img src="images/just_loaded.webp"
alt="selection.rangeCount is 0 just after the page loaded" />
<figcaption aria-hidden="true"><code>selection.rangeCount</code> is 0
just after the page loaded</figcaption>
</figure>
<h3 id="introducing-the-supporting-cast">Introducing the Supporting
Cast‚Ä¶</h3>
<p>If you double-click on the word ‚ÄòClick‚Äô or click and drag to select
it, you‚Äôll see in the grey feedback zone that a Range object is created.
It has four properties that you will be using a lot:</p>
<ul>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startContainer"><code>startContainer</code></a></li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startOffset"><code>startOffset</code></a>,
together with</li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endContainer"><code>endContainer</code></a></li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endOffset"><code>endOffset</code></a></li>
</ul>
<figure>
<img src="images/click_selected.webp"
alt="Selecting the word ‚ÄòClick‚Äô" />
<figcaption aria-hidden="true">Selecting the word ‚ÄòClick‚Äô</figcaption>
</figure>
<p>You might have two surprises here. First, the range has <em>two
container</em> objects: <code>startContainer</code> and
<code>endContainer</code>, although you know that the word ‚ÄòClick‚Äô is
entirely contained in <em>one</em> <code>&lt;p&gt;</code> element.
Second, both the <em>nodeName</em> of both the
<code>startContainer</code> and the <code>endContainer</code> is given
as <code>#text</code>, not as <code>&lt;p&gt;</code>. The element you
created as <code>&lt;p id="one"&gt;</code> is shown as the
<code>range.startContainer.parentElement</code>.</p>
<p>You can see the <code>parentElement</code>‚Äôs full title and more
details of the range object, if you create your own version of this
demo, place a breakpoint in the Debugger just after the
<code>range</code> variable is assigned a value:</p>
<figure>
<img src="images/breakpoint.webp"
alt="In your version of the demo, add a breakpoint after the range variable is set‚Ä¶" />
<figcaption aria-hidden="true">In your version of the demo, add a
breakpoint after the range variable is set‚Ä¶</figcaption>
</figure>
<figure>
<img src="images/debugging_range.webp"
alt="‚Ä¶then observe the range object in the Debugger" />
<figcaption aria-hidden="true">‚Ä¶then observe the range object in the
Debugger</figcaption>
</figure>
<h3 id="whats-a-text-node">What‚Äôs a #text node?</h3>
<p>An HTML element, like a <code>&lt;p&gt;</code> element, can contain
more than just text. It can also contain inline content elements like
<code>&lt;img&gt;</code>, <code>&lt;input&gt;</code> or
<code>&lt;select&gt;</code>, or inline formatting elements like
<code>&lt;i&gt;</code> and <code>&lt;b&gt;</code>. Everything between
these inline elements, and all text inside them, is treated as a
<em>text node</em>. Even the gaps between HTML elements in the HTML page
are considered to be text nodes. Here‚Äôs an example. All the highlighted
characters in the HTML code below are in text nodes, including the
invisible spaces and carriage returns.</p>
<pre class="language-html"><code class="language-html"><i><u>  </u>&lt;p&gt;<u>‚Üµ
    </u>&lt;span&gt;<u>text node in a child span</u>&lt;/span&gt;<u>‚Üµ
    text node in the top-level paragraph‚Üµ
    </u>&lt;code&gt;<u>text node in a code block</u>&lt;/code&gt;<u>‚Üµ</u>
<u>  </u>&lt;/p&gt;</i></code></pre>
<details class="alert" open>
<summary>
White space
</summary>
<p>By default, all consecutive white space in text nodes is collapsed
into a single space (<code></code>) character, so you may not be aware
of how much white space there actually is. But you will need to pay
attention: soon you‚Äôll be having to count every last white space
character, if you want to get your text selection tool to work well.</p>
<p>Notice, for example, how this line in your HTML file contains seven
spaces between ‚Äúdrag‚Äù and ‚Äúto‚Äù‚Ä¶</p>
<pre class="language-html line-numbers" data-start="48"><code class="language-html line-numbers">  &lt;p id="one"&gt;Click and drag       to make a selection üëçüèº&lt;/p&gt;</code></pre>
<p>‚Ä¶ but when this line is rendered in the page, it shows only one:</p>
<figure>
<img src="images/one_space.webp"
alt="Only one space rendered between ‚Äúdrag‚Äù and ‚Äúto‚Äù" />
<figcaption aria-hidden="true">Only one space <em>rendered</em> between
‚Äúdrag‚Äù and ‚Äúto‚Äù</figcaption>
</figure>
</details>
<h3 id="startoffset-and-endoffset">startOffset and endOffset</h3>
<p>When the word ‚ÄòClick‚Äô is selected, the <code>startOffset</code> is
<code>0</code> while the <code>endOffset</code> is set to
<code>5</code>.</p>
<p>You should be used to JavaScript counting from 0, so this should make
good sense to you. Here, the <code>startOffset</code> is saying that
your selection starts when there are 0 characters to the left in the
<code>startContainer</code>, and the <code>endOffset</code> shows that
after the 5-letter word ‚ÄòClick‚Äô, there are 5 characters <i>to the
left</i> in the <code>endContainer</code>‚Ä¶ which in this case is exactly
the same as <code>startContainer</code>.</p>
<details class="note" open>
<summary>
<code>endOffset</code> is exclusive
</summary>
<p>An <code>endOffset</code> of <code>5</code> tells you that
<code>"Click and drag..."[5]</code> (the character at index 5) is
<strong>not</strong> included ind the selection.
<code>"Click and drag..."[5]</code> refers to the <em>space</em> after
the end of the word <code>Click</code>, and not the ‚Äúk‚Äù, which is at
index <code>4</code>.</p>
<p><code>endOffset</code> in <em>exclusive</em>. It always refers to the
first character that is <strong>not</strong> included in the
selection.</p>
</details>
</section>
<!-- Counting White Space -->
<section id="counting-units" aria-labelledby="counting-units" data-item="Counting Units">
<h2>
<a href="#counting-units">Counting Units</a>
</h2>
<p>Time for another experiment. In the demo you used earlier (or in the
version you created for yourself), select from the last letter of ‚Äúdrag‚Äù
to the first letter of ‚Äúto‚Äù.</p>
<figure>
<img src="images/22-13.webp"
alt="One visual space can be many HTML white space characterss" />
<figcaption aria-hidden="true">One visual space can be many HTML white
space characterss</figcaption>
</figure>
<p>On the page, it looks like there is only one space between the start
of the letter ‚Äúg‚Äù in ‚Äúdrag‚Äù and the end of the letter ‚Äút‚Äù in ‚Äútwo‚Äù. But
the <code>range</code> object is looking at the source HTML, and it
keeps a different score. It counts one letter ‚Äúg‚Äù, then seven spaces,
and then one letter ‚Äút‚Äù ‚Äî a difference of 9:</p>
<h3 id="when-a-character-is-more-than-it-appears-to-be">When a character
is more than it appears to be</h3>
<p>Third experiment: select the emoji üëçüèº and check what the values are
for <code>startOffset</code> and <code>endOffset</code>.</p>
<figure>
<img src="images/emoji_selected.webp"
alt="An emoji can count as several characters" />
<figcaption aria-hidden="true">An emoji can count as several
characters</figcaption>
</figure>
<p>Surprised? The demo shows that <code>startOffset</code> is 41 and
<code>endOffset</code> is 45. That suggest that the üëçüèº is four
characters long, but it only takes up one place.</p>
<h3 id="utf-16-units">UTF-16 units</h3>
<p>Computing as we know it today first started in the English-speaking
world. In English, there are 26 letters (a-z), with 52 different signs
for UPPERCASE and lowercase, plus ten digits (0-9), plus a few
punctuations marks like <code>,;;.!?()/%$¬£#'"- ‚Äî‚Ä¶</code>, and of course,
the space. All these characters could be given numbers, with the highest
number staying below 127. By coincidence, the number 127 in decimal is
1111111 in the binary system, and binary numbers are conveniently
bundled in groups of 8 bits, so everything was perfect, and it was
called ASCII. <em>American Standard Code for Information
Interchange</em>.</p>
<p>And this was perfect, at least, for people using the same Latin
alphabet as English.</p>
<p>But there is not just English in the world. There are many different
writing scripts, like Arabic and the Indian Devanagari script, not to
mention languages like Chinese which contain thousands of individual
pictograms. To enable computers to handle all the thousands of different
written symbols, the system of giving each symbol a number had to be
extended.</p>
<p>One standard now is <a
href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a>, which has
variable-length blocks from 8 to 32 bits, and which provides enough
numbers, to label the 1,112,064 different symbols from many different
languages that are recognized today. And it turns out that UTF-16 still
has a few numbers left over, and these are now being used for
emojis.</p>
<p>So you might imagine that an emoji would take two character spaces,
where English letters, numbers and punctuation take only one. But that
is politically incorrect. Emojis that show humans and parts of humans
can have different skin colours, so the üëçüèº emoji takes two values: a
generic thumbs-up plus a skin colour.</p>
<p>To cut a long story short: <code>startOffset</code> and
<code>endOffset</code> do not count characters or bits or bytes. They
count <code>UTF-16 units</code>, and the üëçüèº emoji uses four UTF-16
units.</p>
<p>From now on, I‚Äôll just call them <code>units</code>, and you‚Äôll
discover later just how important it is to think in <em>units</em>
rather than <em>characters</em> when working in with other languages
(and with emojis).</p>
<details class="note" open>
<summary>
Units and Spaces
</summary>
<p>The important point to note is that the Selection and Range objects
use a different system for counting where a selection starts and
finishes than the one that might seem familiar to you.</p>
<p>So now you know, and you can start to think about selections with
this new mental image.</p>
</details>
</section>
<!-- Different Containers -->
<!-- Role of Text Nodes -->
<section id="role-of-text-nodes" aria-labelledby="role-of-text-nodes" data-item="The Role of Text Nodes">
<h2>
<a href="#role-of-text-nodes">The Role of Text Nodes</a>
</h2>
<p>So far, the only selections we have looked at together have started
and ended in the same container. How is a selection represented when it
starts in one HTML element and finishes in another?</p>
<p>Let‚Äôs start with two simple cases. For the first case, click in the
line at the top and drag your mouse down, so that the selection starts
in the first <code>&lt;p&gt;</code> element and ends in the second
<code>&lt;p&gt;</code> element:</p>
<pre class="language-html line-numbers" data-start="46"><code class="language-html line-numbers"><i>    &lt;p id="one"&gt;Click and drag<u>       to make a selection üëçüèº&lt;/p&gt;
    &lt;p id="two"&gt;Your selection </u>can &lt;i&gt;start&lt;/i&gt; on one
    line and &lt;i&gt;end&lt;/i&gt; on another.&lt;/p&gt;</i></code></pre>
<figure>
<img src="images/two_lines.webp"
alt="When startContainer and endContainer are different" />
<figcaption aria-hidden="true">When startContainer and endContainer are
different</figcaption>
</figure>
<p>Note that <code>startOffset</code> gives you the number of units from
the beginning of the text node in the <code>&lt;p id="one"&gt;</code>
paragraph, and that <code>endOffset</code> gives you the number of units
from the beginning of the text node in the
<code>&lt;p id="two"&gt;</code> paragraph. Both of these containers are
identified with the <code>nodeName</code> <code>#text</code>, but the
identity of their <code>.parentElement</code> distinguishes them.</p>
<p>Specifically, notice that neither offset is measured from the
beginning of the page. Each of them is relative to their container.</p>
<h3 id="nested-containers">Nested containers</h3>
<p>Here‚Äôs the second simple case to test. Click somewhere inside the
word ‚Äústart‚Äù (in <i>italics</i>), and drag the selection to somewhere
outside the word, where the text is no longer in italics.</p>
<pre class="language-html line-numbers" data-start="47"><code class="language-html line-numbers"><i>    &lt;p id="two"&gt;Your selection </u>can &lt;i&gt;s<u>tart&lt;/i&gt; on one
    line</u> and &lt;i&gt;end&lt;/i&gt; on another.&lt;/p&gt;</i></code></pre>
<figure>
<img src="images/start_in_i_tag.webp"
alt="Container.parentElements of different types" />
<figcaption aria-hidden="true">Container.parentElements of different
types</figcaption>
</figure>
<p>Note that the <code>startContainer</code>‚Äôs
<code>parentElement</code> is now reported as an <code>i</code> element,
while the <code>endContainer</code>‚Äôs <code>parentElement</code> is
reported as <code>p#two</code>. The <code>&lt;p id="two"&gt;</code>
paragraph has several top-level text nodes, separated by the text nodes
inside the <code>&lt;i&gt;</code> tags, as the image below
illustrates:</p>
<pre class="language-html"><code class="language-html">&lt;p&gt;<u>text node</u>&lt;i&gt;<u>text node</u>&lt;/i&gt;<u>text node</u>&lt;i&gt;<u>text node</u>&lt;/i&gt;<u>text node</u>&lt;/p&gt;</code></pre>
<details class="note" open>
<summary>
Respect for #text nodes
</summary>
<p>In every case, <code>startOffset</code> and <code>endOffset</code>
are calculated <em>from the beginning of the specific text node</em> in
which they occur.</p>
<p>Be sure to note that the <code>parentElement</code> only helps
identify where a given text node occurs, but its position and the length
of its text are never used to <code>startOffset</code> and
<code>endOffset</code>.</p>
</details>
</section>
<!-- Browser Differences -->
<section id="browser-differences" aria-labelledby="browser-differences" data-item="Browser Differences">
<h2>
<a href="#browser-differences">Edge Cases and Browser Differences</a>
</h2>
<p>Earlier, I wrote that you would look at two simple cases. Here‚Äôs a
third case, but it turns out not to be simple at all. The results you
get will depend on which browser you are using, and even how you make
the selection.</p>
<p>Select the words ‚Äú<em>start</em> on one line and <em>end</em>‚Äù,
making sure that the selection begins with the whole word
‚Äú<em>start</em>‚Äù and ends with the whole word ‚Äú<em>end</em>‚Äù.</p>
<p>But try different ways of making this selection:</p>
<ul>
<li>Drag from the beginning of the word ‚Äú<em>start</em>‚Äù to the end of
the word ‚Äú<em>end</em>‚Äù</li>
<li>Double click on the word ‚Äú<em>start</em>‚Äù then press Shift and click
after the word ‚Äú<em>end</em>‚Äù</li>
<li>Select from the beginning of the word ‚Äú<em>start</em>‚Äù to somewhere
in the middle of the word ‚Äú<em>end</em>‚Äù, then use Shift+Right Arrow to
extend the selection to the end of the word ‚Äú<em>end</em>‚Äù</li>
<li>Select from the end of the word ‚Äú<em>end</em>‚Äù to somewhere in the
middle of the word ‚Äú<em>start</em>‚Äù, then use Shift+Left Arrow to extend
the selection to the end of the word ‚Äú<em>start</em>‚Äù</li>
<li>‚Ä¶</li>
</ul>
<p>Try doing this in different browsers. Here are some of the ways the
<code>range</code> values may be set:</p>
<hr />
<pre class="language-html"><code class="language-html">... can &lt;i&gt;<u>start&lt;/i&gt; on one line and &lt;i&gt;end</u>&lt;/i&gt; on...</code></pre>
<figure>
<img src="images/chrome.webp" alt="i 0 to i 3 on Chrome" />
<figcaption aria-hidden="true"><em>i 0</em> to <em>i 3</em> on
Chrome</figcaption>
</figure>
<hr />
<pre class="language-html"><code class="language-html">... can <u>&lt;i&gt;start&lt;/i&gt; on one line and &lt;i&gt;end</u>&lt;/i&gt; on...</code></pre>
<figure>
<img src="images/safari.webp" alt="p#two 19 to i 3 on Safari" />
<figcaption aria-hidden="true"><em>p#two 19</em> to <em>i 3</em> on
Safari</figcaption>
</figure>
<hr />
<pre class="language-html"><code class="language-html">... can &lt;i&gt;<u>start&lt;/i&gt; on one line and &lt;i&gt;end&lt;/i&gt;</u> on...</code></pre>
<figure>
<img src="images/firefox.webp" alt="i 0 to p#two 0 on Firefox" />
<figcaption aria-hidden="true"><em>i 0</em> to <em>p#two 0</em> on
Firefox</figcaption>
</figure>
<hr />
<p>Selections that look exactly the same on the screen may be described
differently by the <code>range</code> object, when the selection
boundary is at the boundary between two containers. All of these
descriptions are correct, but they all have slightly different
meanings.</p>
<p>And try this: double-click on the üëçüèº emoji at the end of
<code>&lt;p id="one"&gt;</code>, then press Shift+Right Arrow.</p>
<figure>
<img src="images/double_click_emoji.webp"
alt="Double click to select the emoji‚Ä¶" />
<figcaption aria-hidden="true">Double click to select the
emoji‚Ä¶</figcaption>
</figure>
<figure>
<img src="images/Shift_Right_Arrow.webp"
alt="‚Ä¶ then press Shift+Right arrow to extend the selection" />
<figcaption aria-hidden="true">‚Ä¶ then press Shift+Right arrow to extend
the selection</figcaption>
</figure>
<p>The visual appearance of the selection will not change, but the
<code>range</code> object will now see that you have extended the
selection to include the invisible carriage return and white space
characters between the two <code>&lt;p&gt;</code> elements.</p>
<pre class="language-html line-numbers" data-start="48"><code class="language-html line-numbers">  &lt;p id="one"&gt;Click and drag       to make a selection üëçüèº&lt;/p&gt;<u>‚Üµ  
  </u>&lt;p id="two"&gt;Your selection can &lt;i&gt;start&lt;/i&gt; on one line and</code></pre>
<h3 id="need-to-normalize">Need to Normalize</h3>
<p>The point to note here is that you cannot trust the Selection data
blindly. You will need to <em>normalize</em> a selection to a specific,
known state, before you start to work with it. Precisely how you
normalize it will depend on how you plan to work with it.</p>
<p>For example, suppose you have text like this:</p>
<blockquote>
<p>Compare <em>short</em>-term and <em>long</em>-term planning</p>
</blockquote>
<p>And suppose one of your end-users makes a partial selection, like
this:</p>
<pre class="language-html"><code class="language-html">Compare &lt;i&gt;short&lt;i&gt;<u>-term and &lt;i&gt;long</u>&lt;i&gt;-term planning</code></pre>
<p>If your app is designed to ensure that whole words are selected, it
will need to change the initial selection to this:</p>
<pre class="language-html"><code class="language-html">Compare <u>&lt;i&gt;short&lt;i&gt;-term and &lt;i&gt;long&lt;i&gt;-term</u> planning</code></pre>
<p>In this case, you will want your app to normalize the start and the
end of the selection in different ways:</p>
<ul>
<li>You want to normalize the start of the selection to begin at the end
of the first &lt;i&gt; tag, so that your app can extend the start
backwards, to add ‚Äú<em>short</em>‚Äù to the word ‚Äú-term‚Äù</li>
<li>You want to normalzie the end of the selection to the beginning of
the text node following the closing &lt;/i&gt; tag, so that your app can
extend the end forwards, to add ‚Äúterm‚Äù to the word ‚Äú<em>long</em>‚Äù.</li>
</ul>
<p>In other words, here‚Äôs how your app would need to normalize the
user‚Äôs selection before using it to extend to include whole words:</p>
<pre class="language-html"><code class="language-html">Compare &lt;i&gt;short<u>&lt;i&gt;-term and &lt;i&gt;long&lt;i&gt;</u>-term planning</code></pre>
<p>Other cases might require different normalization techniques.</p>
<details class="note" open>
<summary>
The lesson to learn here
</summary>
<p>Sometimes you will need to <strong>adjust the raw selection
data</strong> that the browser gives you, so that you can use the
selection the way you want to use it.</p>
</details>
</section>
<!-- Other Selection States -->
<section id="other-selection-states" aria-labelledby="other-selection-states" data-item="Other Selection Cases">
<h2>
<a href="#other-selection-states">Other Selection Cases</a>
</h2>
<h3 id="a-collapsed-selection">A collapsed Selection</h3>
<p>As you saw earlier, before you make your first click on a
newly-opened web page, the Selection object already exists but it does
not yet contain any Range objects. After the first Range object has been
created, a simple click on the page will deselect all text, but the
Range object will continue to exist. No selection will be visible on the
page.</p>
<p>After a simple click, the Selection will simply set its
<code>isCollapsed</code> property to <code>true</code>, the
<code>startOffset</code> and <code>endOffset</code> will be set to the
same numerical value, and the <code>startContainer</code> and
<code>endContainer</code> will both refer to the same text node.</p>
<p>Try clicking on the demo page in different places.</p>
<figure>
<img src="images/invisible_caret.webp"
alt="A click collapses the Selection to an invisible caret" />
<figcaption aria-hidden="true">A click collapses the Selection to an
invisible caret</figcaption>
</figure>
<figure>
<img src="images/isCollapsed.webp" alt="When a Selection isCollapsed" />
<figcaption aria-hidden="true">When a Selection isCollapsed</figcaption>
</figure>
<p>If you click outside any text content, the Selection will still be
collapsed, but the range will not be a text node:</p>
<figure>
<img src="images/all_deselected.webp"
alt="A click to the right of the input field, not in a text node" />
<figcaption aria-hidden="true">A click to the right of the input field,
not in a text node</figcaption>
</figure>
<details class="note" open>
<summary>
Selection.isCollapsed
</summary>
<p>When there is no visible selection in the page:</p>
<ul>
<li>The Selection‚Äôs‚Äô <code>isCollapsed</code> property will be set to
<code>true</code></li>
<li>The <code>startOffset</code> and <code>endOffset</code> will be set
to the same numerical value</li>
<li>The <code>startContainer</code> and <code>endContainer</code> will
both refer to the same text node.</li>
</ul>
</details>
<h3 id="a-selection-with-no-range-object">A Selection with no Range
object</h3>
<p>It‚Äôs possible to destroy the Range object, by selecting something
that the Selection object can‚Äôt directly see. Try typing some text into
the <code>&lt;input type="text"&gt;</code> field, and then select some
of your input text.</p>
<figure>
<img src="images/input_selected0.webp"
alt="The Selection can‚Äôt see text in &lt;input&gt; elements‚Ä¶" />
<figcaption aria-hidden="true">The Selection can‚Äôt see text in
<code>&lt;input&gt;</code> elements‚Ä¶</figcaption>
</figure>
<p>But perhaps you see something different? Perhaps you see that
<code>selection.toString()</code> does indeed show the text that you
selected in the input field:</p>
<figure>
<img src="images/input_selected1.webp" alt="‚Ä¶ or can it?" />
<figcaption aria-hidden="true">‚Ä¶ or can it?</figcaption>
</figure>
<p>This depends on which browser you are using, and whether the
selection that you made just before was collapsed or not.</p>
<details class="note" open>
<summary>
Selection inside an <code>&lt;input type="text"&gt;</code> field
</summary>
<p>The result of selecting inside an
<code>&lt;input type="text"&gt;</code> field is not well-defined.</p>
<p>Depending on the browser and your most recent selection, selecting
text inside an <code>&lt;input type="text"&gt;</code> field can
either:</p>
<ul>
<li>Destroy the Selection‚Äôs Range object</li>
<li>Provide a unexpected value for the <code>startContainer</code> and
<code>endContainer</code>, and display the text selected in the
<code>&lt;input type="text"&gt;</code> field as
<code>Selection.toString()</code></li>
</ul>
</details>
<h3 id="browser-differences-when-you-select-all">Browser differences
when you Select All</h3>
<p>WHen you user the Menu item Edit &gt; Select All, or the
corresponding keyboard shortcut, different browsers will display the
selection differently on the page, and Selection.toString() may have
different values.</p>
<p>Chrome and Edge mostly agree; Safari also highlights empty space to
the left. Firefox does things differently:</p>
<ul>
<li>Firefox includes invisible carriage returns known only to the
HTML</li>
<li>Firefox does not highlight text in an
<code>&lt;input type="text"&gt;</code> field</li>
<li>Firefox includes the <em>alt</em> text of an image in
Selection.string()</li>
</ul>
<p>All browsers agree, though, <strong>not</strong> to include:</p>
<ul>
<li>The text of <code>::before</code> and <code>::after</code> and other
pseudo-elements</li>
<li>Elements with the CSS rule: <code>{ user-select: none }</code></li>
</ul>
<figure>
<img src="images/select_all_chrome.webp" alt="Select All on Chrome" />
<figcaption aria-hidden="true">Select All on Chrome</figcaption>
</figure>
<figure>
<img src="images/select_all_safari.webp" alt="Select All on Safari" />
<figcaption aria-hidden="true">Select All on Safari</figcaption>
</figure>
<figure>
<img src="images/select_all_edge.webp" alt="Select All on Edge" />
<figcaption aria-hidden="true">Select All on Edge</figcaption>
</figure>
<figure>
<img src="images/select_all_firefox.webp" alt="Select All on Firefox" />
<figcaption aria-hidden="true">Select All on Firefox</figcaption>
</figure>
<details class="alert" open>
<summary>
Test early, test often, test on all target browsers
</summary>
<p>You probably don‚Äôt need to be reminded of this, but you can‚Äôt trust
all browsers to behave the same way, and you need to make sure that your
code is working exactly the way you expect on all the browsers that you
end-users are likely to use.</p>
</details>
</section>
<!-- Word Boundaries -->
<section id="word-boundaries" aria-labelledby="word-boundaries" data-item="Word Boundaries">
<h2>
<a href="#word-boundaries">Word Boundaries</a>
</h2>
<p>Where does one word end and the next word begin? Since your early
childhood, you have been able to detect word boundaries in spoken
speech. Try asking a two-year old to say ‚Äúspeedboat‚Äù. (Make sure you
pronounce the ‚Äúd‚Äù.) The chances are that the child will answer with two
words with a distinct gap between them: ‚Äúspeed ‚Ä¶ boat‚Äù. That‚Äôs because
the sequence ‚Äúdb‚Äù is very unusual in English words. Before children can
say the words ‚Äústatistical probability‚Äù, their brains are busy analysing
the sounds they hear according to statistical probability.</p>
<p>You need to take a quick glance at these two sentences to know that
they are different, and that the words need to be pronounced
differently, possibly with a different accent:</p>
<blockquote>
<p>The irregular program mess ends now.</p>
<p>Their regular programmes send snow.</p>
</blockquote>
<p>But both sentences use the exact same letters in the exact same
order, and only the position of the spaces change. Your brain can
immediately see the differences, and may not even notice the similarity
until it is pointed out to you.</p>
<p>In this project, which aims to to ensure that every selection starts
and ends with a whole word, you‚Äôll somehow need to explain to your
browser what a whole word is, even when there are HTML tags to confuse
it.</p>
<p>Does the following HTML seem clear to you, now, even when you know
what you are looking for?</p>
<pre class="language-html wrap"><code class="language-html wrap">&lt;p id="source"&gt;&lt;i class="after"&gt;The&lt;u&gt; &lt;/u&gt;ir&lt;/i&gt;&lt;b&gt;regular program&lt;u&gt; &lt;/u&gt;mes&lt;/b&gt;&lt;i class="before after"&gt;s&lt;u class="space"&gt; &lt;/u&gt;end&lt;/i&gt;s&lt;u class="space"&gt; &lt;/u&gt;now.&lt;/p&gt;</code></pre>
<h3 id="enter-intl.segmenter">Enter <code>Intl.Segmenter</code></h3>
<p>A new API was <a
href="https://caniuse.com/?search=Intl.Segmenter">recently</a> added to
JavaScript as a global object in all major browsers: <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter">Intl.Segmenter</a>.</p>
<p>Below is a demo that uses the Intl.Segmenter to parse the text of the
HTML chunk just above. Here is the code that creates the segment objects
that you see in the demo:</p>
<pre class="language-javascript line-numbers" data-start="77"><code class="language-javascript line-numbers">      const source = document.getElementById("source");</code></pre>
<pre class="skip"><code class="skip">...</code></pre>
<pre class="language-javascript line-numbers" data-start="84"><code class="language-javascript line-numbers">        const text = source.textContent;

        const lang = "en";
        const options = { granularity: "word" };
        const segmenter = new Intl.Segmenter(lang, options);
        const words = Array.from(segmenter.segment(text));</code></pre>
<p>Note that you need to tell the Intl.Segmenter instance what
<code>lang</code>uage the input is going to be in, and what
<code>granularity</code> you want to use.</p>
<p>If you click on the checkbox in the green section at the top, a
series of rules are applied to the different <code>&lt;i&gt;</code> and
<code>&lt;u&gt;</code> blocks within that HTML chunk, in order to force
the text to <em>appear</em> differently in the browser. The HTML itself
does not change.</p>
<p>However, the Intl.Segmenter cuts through the formatting noise, and
just reads the raw <code>textContent</code> of the
<code>&lt;p id="source"&gt;</code> element. It ignores any CSS
formatting that may or may not be applied. As a result, as you can see,
it produces exactly the same <code>segments</code> whether the checkbox
is checked on not.</p>
<iframe id="intl-segmenter" title="intl-segmenter" width="480" height="480" src="https://merncraft.github.io/Intl-Segmenter">
</iframe>
<details class="tldr">
<summary>
Try This at Home
</summary>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;Word Boundaries&lt;/title&gt;
    &lt;style&gt;
      body {
        display: flex;
        flex-direction: column;
        margin: 0;
        height: 100vh;
        color: #ddd;
        background-color: #111;

        label {
          padding: 1em;
          background-color: #060;
        }

        #source {
          font-size: 1.5em;
          color: #0c0;
        }

        u {
          text-decoration: none;
        }

        &:has(input:checked) {
          & #source {
            color: #c00;

            /* use non-breaking spaces to force letters apart */
            i.after {
              &::after {
                content: "\00A0";
                display: inline-block;
              }
            }
            i.before::before {
              content: "\00A0";
              display: inline-block;
            }
            u {
              font-size: 0;
            }
          }
        }

        #segments {
          flex: 1;
          overflow-y: auto;
        }

        pre {
          white-space: pre-wrap;
          
          &::first-line {
            font-size: 1.5em;
          }
        }
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;label&gt;
      &lt;span&gt;Use confusing CSS to change the spacing: &lt;/span&gt;
      &lt;input type="checkbox" id="checkbox"&gt;
    &lt;/label&gt;
    &lt;p id="source"&gt;&lt;i class="after"&gt;The&lt;u&gt; &lt;/u&gt;ir&lt;/i&gt;&lt;b&gt;regular program&lt;u&gt; &lt;/u&gt;mes&lt;/b&gt;&lt;i class="before after"&gt;s&lt;u class="space"&gt; &lt;/u&gt;end&lt;/i&gt;s&lt;u class="space"&gt; &lt;/u&gt;now.&lt;/p&gt;
    &lt;pre id="words"&gt;&lt;/pre&gt;
    &lt;pre id="segments"&gt;&lt;/pre&gt;

    &lt;script&gt;
      const checkbox = document.getElementById("checkbox");
      const source = document.getElementById("source");
      const wordsPre = document.getElementById("words");
      const segmentsPre = document.getElementById("segments");

      checkbox.addEventListener("change", segmentText)

      function segmentText() {
        const text = source.textContent;

        const lang = "en";
        const options = { granularity: "word" };
        const segmenter = new Intl.Segmenter(lang, options);
        const words = Array.from(segmenter.segment(text));
        const justWords = words
          .filter((item) =&gt; item.isWordLike)
          .map((item) =&gt; item.segment);

        wordsPre.textContent = `words:
${JSON.stringify(justWords, null, "  ")}`;
        segmentsPre.textContent = `segments:
${JSON.stringify(words, null, "  ")}`;
      }

      segmentText()
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>
<p>First, I‚Äôll show you how to create a mental image of what
Intl.Segmenter does, and then you can practise getting it to work
together with the Selection, Range and container objects that you have
already seen.</p>
</section>
<style>
  code u,
  code u * {
    background-color: #368 !important;
    filter: brightness(1);
  }
</style>
<section id="intro" aria-labelledby="intro" data-item="Introduction">
<h2>
<a href="#intro">Introduction</a>
</h2>
<iframe id="demo" title="demo" width="600" height="300" src="https://merncraft.github.io/SplitSpansDemo/">
</iframe>
<h3 id="whats-in-store-for-you">What‚Äôs in Store for You</h3>
<h4 id="part-1-selection">Part 1: Selection</h4>
<ol type="1">
<li>window.getSelection()</li>
</ol>
<ul>
<li>What it returns (a Selection object)</li>
<li>Multiple ranges? (selection.rangeCount)</li>
<li>Basic usage examples (toString(), getRangeAt(0))</li>
</ul>
<ol start="2" type="1">
<li>The Range object</li>
</ol>
<ul>
<li>Properties: startContainer, startOffset, endContainer, endOffset,
commonAncestorContainer</li>
<li>Methods: selectNode, selectNodeContents, setStart, setEnd,
cloneRange</li>
<li>Why you often want a Range instead of just the selection string</li>
</ul>
<ol start="3" type="1">
<li>Text nodes vs element nodes</li>
</ol>
<ul>
<li>What a text node is (nodeType === 3)</li>
<li>How inline elements affect selections (<code>&lt;b&gt;</code>,
<code>&lt;i&gt;</code>, <code>&lt;span&gt;</code>)</li>
<li>Why startContainer can be a text node or an element (Safari
quirk)</li>
<li>Using childNodes to inspect the DOM structure</li>
</ul>
<ol start="4" type="1">
<li>Selection offsets</li>
</ol>
<ul>
<li>Offsets relative to the container (text node vs element)</li>
<li>Why startOffset and endOffset may not correspond to visible
characters exactly (whitespace, hidden nodes, zero-length nodes)</li>
<li>Common mistakes when computing offsets directly
<ul>
<li>Treating offsets as global visible positions</li>
<li>Assuming containers are always text nodes</li>
<li>Forgetting that whitespace rules affect selectable characters</li>
<li>Not accounting for invisible/empty text nodes</li>
<li>Treating endOffset as inclusive</li>
<li>Misunderstanding UTF-16 vs grapheme clusters</li>
<li>Using textContent.length as if spans were one node</li>
<li>Misinterpreting backwards selections</li>
<li>Mutating the DOM before preserving Range info</li>
</ul></li>
</ul>
<ol start="5" type="1">
<li>Browser differences</li>
</ol>
<ul>
<li>Safari quirks:</li>
<li>startContainer may be in a previous element‚Äôs text node</li>
<li>Selections may ‚Äúsnap‚Äù across inline boundaries</li>
<li>Chrome/Firefox generally behave consistently</li>
<li>Implications for algorithms that rely on DOM offsets</li>
</ul>
<ol start="6" type="1">
<li>Clamping / normalizing selections</li>
</ol>
<ul>
<li>Concept: adjusting startContainer and endContainer to the
‚Äúfirst/last selectable text node‚Äù in the intended range</li>
<li>Why this is needed before doing any text manipulation or
word-boundary expansion</li>
<li>Example: ‚ÄúSnap selection start to 0 offset of first text node inside
element‚Äù</li>
</ul>
<ol start="7" type="1">
<li>Traversing selected text</li>
</ol>
<ul>
<li>Why you need to iterate all text nodes between startContainer and
endContainer</li>
<li>Introduce TreeWalker or NodeIterator for walking the DOM</li>
<li>Differences between childNodes iteration vs TreeWalker (nested
inline elements)</li>
</ul>
<ol start="9" type="1">
<li>Handling whitespace white-space CSS affects what is visually
selectable</li>
</ol>
<ul>
<li>pre-wrap vs normal vs nowrap</li>
<li>How this affects offset calculations</li>
<li>Note: pseudo-elements (::before, ::after) are ignored because they
aren‚Äôt selectable</li>
</ul>
<ol start="9" type="1">
<li>Edge cases and best practices</li>
</ol>
<ul>
<li>Empty elements or elements with no text nodes</li>
<li>Nested inline elements (<b><i>text</i></b>)</li>
<li>Collapsed nodes or nodes with only whitespace</li>
<li>Using Range.compareBoundaryPoints to detect containment</li>
</ul>
<ol start="10" type="1">
<li>Topics to explore further</li>
</ol>
<ul>
<li>Using range.getClientRects() for visual selection bounds</li>
<li>Multi-range selections (rare, but good to mention)</li>
<li>How selection APIs interact with contenteditable areas</li>
<li>Selection normalization strategies from popular editors
(ProseMirror, Slate)</li>
</ul>
<h4 id="part-2-detecting-word-boundaries">Part 2: Detecting word
boundaries</h4>
<ol type="1">
<li>How browser understand word boundaries</li>
<li>Intl.Segmenter basics</li>
<li>Mapping segmenter offsets back to the DOM</li>
<li>Working no-break characters</li>
<li>Language-specific rules for punctuation</li>
<li>Boundaries around inline formatting</li>
<li>Identifying blocks that should not be broken</li>
<li>Words that span DOM nodes, for whatever reason</li>
<li>Special case: Speaker change em-dash for subtitles</li>
</ol>
<h4 id="part-3-splitting-and-merging-elements">Part 3: Splitting and
merging elements</h4>
<ol type="1">
<li>How Range mutations work</li>
<li>Splitting text nodes and inline structures</li>
<li>Extracting content with extractContents()</li>
<li>Safe merging: style checks, tagName checks</li>
<li>Wrapping selection in spans</li>
<li>Avoiding nested span hell</li>
<li>Removing/redesigning wrappers</li>
<li>Adding a class to new spans</li>
</ol>
<h4 id="mini-projects">Mini Projects</h4>
<ul>
<li><p>Project 1: Basic selection Single text node, no formatting Goal:
get selected text and offsets</p></li>
<li><p>Project 2: Inline formatting <code>&lt;b&gt;</code> or
<code>&lt;i&gt;</code> inside text Goal: understand startContainer and
endContainer with nested tags</p></li>
<li><p>Project 3: Multi-span selection Two adjacent
<code>&lt;span&gt;</code> elements Goal: see how selection crosses
elements, offsets are computed</p></li>
<li><p>Project 4: Whitespace handling Show white-space: pre-wrap vs
normal Goal: see which characters are actually selectable</p></li>
</ul>
<p>Project 5: Safari quirk Cross-span startContainer issue Goal:
understand why clamping/normalization is needed</p>
<ul>
<li><p>Project 6: Introduction to TreeWalker Walk selected text nodes,
accumulate text Goal: show how to reliably collect selected
text</p></li>
<li><p>Project 7: Selection clamping Normalize selection start/end to
first/last text node Goal: ready for word-boundary expansion in Part
2</p></li>
</ul>
<hr />
<ul>
<li>Whole-word expansion</li>
<li>Splitting text out of existing spans</li>
<li>Splitting <code>&lt;b&gt;</code>, <code>&lt;i&gt;</code>, etc. at
selection boundaries</li>
<li>Creating a new span exactly around the selection</li>
<li>Merging neighboring spans when appropriate</li>
<li>Normalizing Safari‚Äôs misaligned selection containers</li>
<li>DOM text walking</li>
<li>Range manipulation</li>
</ul>
<details class="tldr">
<summary>
TL;DR: My personal use case
</summary>
<p>I teach English as a foreign language to adults. I have friends who
teach their own native languages, to adults and to children. A big
question that we have is: ‚ÄúHow to make learners want to spend time
practising their new language?‚Äù One way is to get them to watch films in
their target language. Or perhaps better yet (and free): get them to
watch short YouTube videos on subjects that interest them.</p>
<h3 id="youtube-auto-generated-transcripts">YouTube auto-generated
transcripts</h3>
<p>Many YouTube videos provide subtitles, and an interactive transcript.
You can show the subtitles by clicking on the
<code>Subtitles/closed caption</code> button in the YouTube toolbar, and
you can show the transcript by ‚Ä¶</p>
<ul>
<li>Clicking on the <code>more...</code> button in the summary</li>
<li>Scrolling to near the end to find the <code>Show Transcript</code>
button</li>
<li>Making your web page wide enough to see the interactive transcript
to the side of your video.</li>
</ul>
<p>But the YouTube website is design for YouTube to optimize revenue.
Our language students don‚Äôt need all the ads and links and extra
content. They really just want a good video to watch, and help with
understanding what is being said.</p>
<p>Auto-generated subtitles can be wildly wrong and confusing. Even when
they are accurate, the timing of the subtitles can be awkward and
imprecise. A subtitle might contain speech both before and after a scene
change, and it might be too long to be comfortable. The transcript is
broken up into timed chunks that might not correspond to actual
sentences.</p>
<h3 id="doing-it-better">Doing it better</h3>
<p>I wanted to create something more like the system provided by <a
href="https://www.ted.com/talks/joshua_foer_feats_of_memory_anyone_can_do/transcript">ted.com</a>,
which:</p>
<ul>
<li>Shows the transcript in natural paragraphs</li>
<li>Uses a separate span for each natural break in the speech</li>
<li>Provides transcripts created by humans and translated by humans into
many different languages.</li>
</ul>
<p>I also wanted to add a feature that allows language learners to play
a particular phrase or sentence in a loop, perhaps a little more slowly,
so that they have the chance to hear how the speaker actually pronounces
the words.</p>
<p>A subtitle might say: ‚ÄúIt‚Äôs going to be good!‚Äù but the speaker might
make a sound like ‚ÄúSgonnbegooh!‚Äù It can take a learner a little time to
get used to the shortcuts native speakers make, that other native
speakers can easily understand.</p>
<p>So, before releasing my ‚ÄúLearn a language through YouTube‚Äù app, I had
to make myself a tool that would allow me to:</p>
<ul>
<li>Paste a YouTube URL</li>
<li>Automatically download the transcript</li>
<li>Automatically download the audio file, and generate a waveform
graphic from it, so I could easily see where sounds began and ended</li>
<li>Edit the text of the auto-generated transcript</li>
<li>Divide the transcript into natural segments for subtitles</li>
<li>Set the start and end times of each subtitle precisely</li>
<li>Allow a translator to follow the video and the original subtitles
while making a translation</li>
<li>Provide the translator with some flexibility about subtitle timing,
as different languages give the same information in a different
order.</li>
<li>Export the subtitles in the standard SRT format, to be used by my
‚ÄúLearn a language through YouTube‚Äù app.</li>
</ul>
<p>Hence the need to split and merge the text of HTML spans, as
described in this tutorial.</p>
<p>You can find the Subtitle Optimizer tool <a href="">here</a>, and the
‚ÄúLearn a language through YouTube‚Äù app <a
href="https://stv.jazyx.com">here</a>.</p>
<blockquote>
<h3 id="fun-fact">Fun Fact</h3>
<p>One advantage of watching YouTube videos embedded in third-party site
is that <strong>the videos are never interrupted by ads</strong>.</p>
<p>And yes, I contact the content creators whose videos I link to, to
make sure that they are happy that their work is used in this
educational manner, even if it means that they don‚Äôt earn any ad revenue
from it.</p>
</blockquote>
</details>
</section>

<div class="spacer"></div>
<footer id="content-footer">
<button type="button" class="previous" disabled>
  <img src="../public/svg/prev.svg" alt="prev" draggable="false">
</button>
<span class="previous-name"></span>
<span class="spacer"></span>
<button type="button" class="next">
  <img src="../public/svg/next.svg" alt="next" draggable="false">
</button>
<span class="next-name"></span>
</footer>
</main>

<nav
id="menu"
aria-labelledby="menu"
class="open"
>
<div class="theme">
  <label
  title="Dark"
  >
  <img src="../public/svg/dark.svg" alt="dark">
  <input
  type="radio"
  name="theme"
  id="theme-dark"
  checked
  >
  </label>
  <label
  title="Light"
  >
  <img src="../public/svg/light.svg" alt="light">
  <input
  type="radio"
  name="theme"
  id="theme-light"
  >
  </label>
  </div>
  <div class="paging">
  <label
  title="Split into sections"
  >
  <img src="../public/svg/pages.svg" alt="pages">
  <input
  type="radio"
  name="paging"
  id="pages"
  checked
  >
  </label>
  <label
  title="Show as a single page"
  >
  <img src="../public/svg/scroll.svg" alt="scroll">
  <input
  type="radio"
  name="paging"
  id="scroll"
  >
  </label>
  </div>
<img src="../public/svg/hamburger.svg" alt="menu" id="menu-icon">

<ul id="menu-items">
</ul>
<div id="repo">
<a
href="https://github.com/MERNCraft/SplitSpans/issues/new"
>
Feedback
</a>

<a
class="repo"
href="https://github.com/MERNCraft/SplitSpans"
>
<img src="../public/svg/github.svg" alt="github logo">
<span>GitHub repository</span>
</a>
</div>
</nav>
</body>
</html>