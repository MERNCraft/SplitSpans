<!-- Intl.Segmenter output -->
<section
  id="intl-segmenter-format"
  aria-labelledby="intl-segmenter-format"
  data-item="Segment Format"
>
  <h2><a href="#intl-segmenter-output">Segment Format</a></h2>

When you first met the Intl.Segmenter, you saw what it the output of its `segment()` method is, when the `granularity` is set to `"word"`:
  

```js-#
[
  {
    "segment": "The",
    "index": 0,
    "input": "The irregular program mess ends now.",
    "isWordLike": true
  },
  {
    "segment": " ",
    "index": 3,
    "input": "The irregular program mess ends now.",
    "isWordLike": false
  }, ...
]
```

Each consecutive object contains four property/value pairs:

1. `"segment"`: a string (in this case, a whole word)
2. `"index"`: a non-negative number, indicating where the segment string starts in the text that was segmented
3. `"input"`: the entire text that was segmented

And, only when the options argument is `{ granularity: "word" }`:

4. **`"isWordLike"`**: `true` or `false`, depending on whether `"segment"` represents a word (`true`) or a non-word character like white space or a punctuation mark (`false`).

### `{ granularity: "grapheme" }`

The `"isWordLike"` property is not included in items generated with `{ granularity: "grapheme" }`, because there are no words: each `"segment"` is exactly one grapheme long.

As you have already seen with emojis and Tamil, a grapheme can contain several code points, so the `"index"` of the following item might increase by more than one. If you look back at the [Counting Units](#counting-units) section, you'll see that `"index"` here refers to the same `UTF-16 units` that the `Range` object's `startOffset` and `endOffset` counts.

```js-#
[
  {
    "segment": "T",
    "index": 0,
    "input": "The irregular program mess ends now."
  },
  {
    "segment": "h",
    "index": 1,
    "input": "The irregular program mess ends now."
  },
  {
    "segment": "e",
    "index": 2,
    "input": "The irregular program mess ends now."
  },
  {
    "segment": " ",
    "index": 3,
    "input": "The irregular program mess ends now."
  }, ...
]
```

### `{ granularity: "sentence" }`

Unlike with `{ granularity: "words" }`, you will only find individual graphemes when `{ granularity: "sentence" }`, if you use an unconventional writing style:

In the example below, both the singular opening parenthesis characters `)` are treated as the first character in a sentence. This leads to the last "sentence" being an opening parenthesis character `)` all on its own.

```node-#
> segmenter = new Intl.Segmenter("en", { granularity: "sentence" })
Segmenter [Intl.Segmenter] {}
> Array.from(segmenter.segment("Don't worry! Be happy!  )")) 
[
  {
    segment: "Don't worry! ",
    index: 0,
    input: "Don't worry! Be happy!  )"
  },
  {
    segment: 'Be happy!  ',
    index: 13,
    input: "Don't worry! Be happy!  )"
  },
  { segment: ')', index: 24, input: "Don't worry! Be happy!  )" }
]
```

In other words, this last individual character is not a separate grapheme: it is a sentence of its own.

The spaces that follow after a sentence are all included as part of that sentence. There are no separate entries for spaces like there are with `{ granularity: "words" }`. 

</section>