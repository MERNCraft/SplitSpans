<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta
name="viewport"
content="width=device-width, initial-scale=1.0"
>
<title>Selecting Whole Words</title>
<link rel="stylesheet" href="../public/styles.css">
<link rel="stylesheet" href="../public/media-queries.css">
<link rel="stylesheet" href="../public/prism/prism.css">

<script defer src="../public/prism/prism.js"></script>
<script defer src="../public/storage.js"></script>
<script defer src="../public/script.js"></script>
</head>

<body>
<main id="content">
<header>
<a href="https://MERNCraft.github.io"><img src="../public/svg/home.svg" alt="home"></a>
<h1>Selecting Whole Words</h1>
<h3>with window.getSelection() and Intl.Segmenter</h3>
<h4>November 2025</h4>
</header>
<nav
  id="content-header"
  aria-labelledby="content-header"
>
  <button type="button" class="previous" disabled>
    <img src="../public/svg/prev.svg" alt="previous" draggable="false">
  </button>
  <span class="previous-name"></span>
  <span class="spacer"></span>
  <button type="button" class="next">
    <img src="../public/svg/next.svg" alt="next" draggable="false">
  </button>
  <span class="next-name"></span>
</nav>

<!-- The Selection Object -->
<section id="the-selection-object" aria-labelledby="the-selection-object" data-item="The Selection Object">
<h2>
<a href="#the-selection-object">The Selection Object</a>
</h2>
<p>Before you can master a field of knowledge, you need to be able
create clear mental images, which are not too different from the reality
that you need to deal with. One good way to do this is with hands-on
manipulation, where you can get immediate feedback on the effect of the
changes that you make.</p>
<p>I‚Äôll start by introducing two leading characters in the story that
will unfold: the <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Selection">Selection</a>
and the <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range">Range</a>
object. And then I‚Äôll show you the interplay between them and their
supporting cast: <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startContainer">range.startContainer</a>
with its companion <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startOffset">range.startOffset</a>,
together with <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endContainer">range.endContainer</a>
with its companion <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endOffset">range.endOffset</a>.</p>
<h3 id="the-selection-object">The Selection object</h3>
<p>From the moment you launch a web page, the browser window has a <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Selection">Selection</a>
object, which JavaScript gives you access to. The official way to talk
to it is as <code>window.getSelection()</code>, but throughout this
tutorial, I will be assigning this to a variable, so you can call it
<code>selection</code>, for short.</p>
<p>When you drag to select an image or some text in a web page, the
<code>selection</code> updates internally, to reflect whatever is
currently selected. When you select text, the plain text version of what
you selected is available through <code>selection.toString()</code>.
Indeed, if you just <code>console.log(selection)</code>, what you will
see is a string of plain text (or perhaps an empty string, if no text is
selected.)</p>
<p>This is what is showen at the top of grey feedback section</p>
<h3 id="the-range-object">The Range object</h3>
<p>Each selected section is in fact stored in a <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range">Range</a>
object. In browsers that support multiple Range objects, there can be
many separate selected areas on the page.</p>
<h3 id="selective-vision">Selective Vision?</h3>
<p>However, the Selection object does not have access to everything that
you see on a page. For example, <code>selection</code> has no access
to:</p>
<ul>
<li>Pseudo-elements, like <code>::before</code> or <code>::after</code>,
or any <code>::marker</code> for a list item</li>
<li>The text of <code>&lt;input&gt;</code> elements,
<code>&lt;select&gt;</code> elements and <code>&lt;textarea&gt;</code>
elements</li>
<li>Any elements with a CSS styling of
<code>user-select: none</code>.</li>
</ul>
<p>The selection <strong>can</strong> however contain formatting tags
and their content, like
<code>This chunk with &lt;i&gt;italic&lt;/i&gt; text.</code>
<strong>Note</strong> that <code>selection.toString()</code> will show
only plain text, even if the <code>selection</code> does in fact hold
formatted text.</p>
<h3 id="see-for-yourself">See for yourself</h3>
<p>To get an idea of what <code>selection</code> can and cannot see,
click and drag to make some selections in the demo below, and watch how
the text in the grey feedback zone changes.</p>
<iframe id="selection-and-range" title="Selection and Range" width="480" height="480" src="https://merncraft.github.io/SelectionAndRange/">
</iframe>
<p>Try selecting different parts of the page:</p>
<ul>
<li>The text at the top</li>
<li>The emoji</li>
<li>Both lines of text together</li>
<li>The words ‚ÄúDIV‚Äù</li>
<li>The image</li>
<li>The text in italics‚Ä¶ and some text to either side of it</li>
<li>The text in the input field</li>
<li>The text in the grey feedback zone that displays what the Selection
object is aware of</li>
<li>The entire contents of the page</li>
</ul>
<p>Also, try simply clicking somewhere in the text without making any
selection.</p>
<details class="tip" open>
<summary>
Keep the demo accessible for testing
</summary>
<p>You might like to open this page in a second browser window, so that
you can keep this demo available side-by-side for testing as you scroll
down in this window to read the rest of the tutorial.</p>
<p>Alternatively, you can create your own version of the demo and open
it in a separate window.</p>
<p>You can find the full script of this demo in the <em>Try This at
Home</em> section below. I‚Äôll be quoting extracts of the script in what
follows, so that you can see how the code works.</p>
</details>
<details class="solution">
<summary>
Try This at Home
</summary>
<p>To create the same demo on your own computer, you can clone the <a
href="https://github.com/MERNCraft/SelectionAndRange">GitHub
repository</a>, or follow the instructions below.</p>
<ol type="1">
<li>Greate a file called <code>getSelection.html</code></li>
<li>Copy and paste the HTML shown below into it</li>
<li>Open the file in your Browser</li>
</ol>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;title&gt;getSelection&lt;/title&gt;
  &lt;style&gt;
    body {
      color: #ddd;
      background-color: #111;
    }
    div#image {
      text-align: center;
      img {
        vertical-align: middle;
      }
      &::before {
        content: "::before\00a0\00a0";
      }
      &::after {
        content: "\00a0\00a0::after"
      }
    }
    input {
      margin: 1em 0;
      width: 100%;
    }
    pre {
      background-color: #333;
      min-height: 1em;
      margin-top: 0;
      white-space: pre-wrap;
    }
    pre,
    .feedback {
      -webkit-user-select: none;
      user-select: none;

      & span {
        display: inline-block;
        font-family: monospace;
        text-decoration: underline;
        width: 100%;
        text-align: center;
      }
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p id="one"&gt;Click and drag       to make a selection üëçüèº&lt;/p&gt;
  &lt;p id="two"&gt;Your selection can <i>start</i> on one line and <i>end</i> on another.&lt;/p&gt;
  &lt;div id="image"&gt;
    &lt;img
      src="https://picsum.photos/48/48"
      alt="random image from https://picsum.photos/48/48"
    &gt;
  &lt;/div&gt;
  &lt;input type="text" placeholder="text input"&gt;
  &lt;div class="feedback"&gt;
    &lt;span&gt;selection.toString()&lt;/span&gt;
    &lt;pre id="selection"&gt;&lt;/pre&gt;
  &lt;/div&gt;
  &lt;div class="feedback"&gt;
    &lt;span&gt;selection.getRangeAt(0)&lt;/span&gt;
    &lt;pre id="range"&gt;&lt;/pre&gt;
  &lt;/div&gt;

  &lt;script&gt;
    let ii = 0
    const selectionP = document.getElementById("selection")
    const rangeP = document.getElementById("range")

    const selection = window.getSelection()

    setInterval(showSelection, 100)

    function showSelection() {
      if (!selection.rangeCount) {
        selectionP.innerText = "selection.rangeCount: 0"
        rangeP.innerText = ""
        return
      }

      const range = selection.getRangeAt(0)

      const start = range.startContainer
      const startName = start.nodeName
      let startParent = range.startContainer.parentElement
      let id = startParent.id
      startParent = startParent.tagName.toLowerCase()
                  + (id ? `#${id}` : "")

      const end = range.endContainer
      const endName = end.nodeName
      let endParent = range.endContainer.parentElement
      id = endParent.id
      endParent = endParent.tagName.toLowerCase()
                + (id ? `#${id}` : "")

      selectionP.innerText = selection

      rangeP.innerText =
`range.startContainer.nodeName:      ${startName}
range.startContainer.parentElement: ${startParent}
range.startOffset:                  ${range.startOffset}

range.endContainer.nodeName:        ${endName}
range.endContainer.parentElement:   ${endParent}
range.endOffset:                    ${range.endOffset}`
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>
<h3 id="observing-the-selection-and-its-range-object">Observing the
Selection and its Range object</h3>
<p>The window‚Äôs Selection object is created as soon as the page loads.
As you can see in the script in the Try This at Home section, you can
get a pointer to it using <code>window.getSelection()</code>.</p>
<p>If there is something selected on the page, the Selection object will
have at least one Range object. The number of Range objects currently in
use is given by <code>selection.rangeCount</code>.</p>
<p>But as the next script extract and image show, when the page is first
loaded, before the first click, nothing is selected, and the selection
has no Range objects to share. Its <code>rangeCount</code> is initially
zero.</p>
<pre class="language-js line-numbers" data-start="71"><code class="language-js line-numbers"><b>    const selection = window.getSelection()</b>

<i>    setInterval(showSelection, 100)

    function showSelection() {</i>
<b>      if (!selection.rangeCount) {
        selectionP.innerText = "selection.rangeCount: 0"</b><i>
        rangeP.innerText = ""
        return
      }</i></code></pre>
<pre class="skip"><code class="skip">...</code></pre>
<pre class="language-js line-numbers" data-start="108"><code class="language-js line-numbers">    <i>}</i></code></pre>
<figure>
<img src="images/just_loaded.webp"
alt="selection.rangeCount is 0 just after the page loaded" />
<figcaption aria-hidden="true"><code>selection.rangeCount</code> is 0
just after the page loaded</figcaption>
</figure>
<h3 id="introducing-the-supporting-cast">Introducing the Supporting
Cast‚Ä¶</h3>
<p>If you double-click on the word ‚ÄòClick‚Äô or click and drag to select
it, you‚Äôll see in the grey feedback zone that a Range object is created.
It has four properties that you will be using a lot:</p>
<ul>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startContainer"><code>startContainer</code></a></li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startOffset"><code>startOffset</code></a>,
together with</li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endContainer"><code>endContainer</code></a></li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endOffset"><code>endOffset</code></a></li>
</ul>
<figure>
<img src="images/click_selected.webp"
alt="Selecting the word ‚ÄòClick‚Äô" />
<figcaption aria-hidden="true">Selecting the word ‚ÄòClick‚Äô</figcaption>
</figure>
<p>You might have two surprises here. First, the range has <em>two
container</em> objects: <code>startContainer</code> and
<code>endContainer</code>, although you know that the word ‚ÄòClick‚Äô is
entirely contained in <em>one</em> <code>&lt;p&gt;</code> element.
Second, both the <em>nodeName</em> of both the
<code>startContainer</code> and the <code>endContainer</code> is given
as <code>#text</code>, not as <code>&lt;p&gt;</code>. The element you
created as <code>&lt;p id="one"&gt;</code> is shown as the
<code>range.startContainer.parentElement</code>.</p>
<p>You can see the <code>parentElement</code>‚Äôs full title and more
details of the range object, if you create your own version of this
demo, place a breakpoint in the Debugger just after the
<code>range</code> variable is assigned a value:</p>
<figure>
<img src="images/breakpoint.webp"
alt="In your version of the demo, add a breakpoint after the range variable is set‚Ä¶" />
<figcaption aria-hidden="true">In your version of the demo, add a
breakpoint after the range variable is set‚Ä¶</figcaption>
</figure>
<figure>
<img src="images/debugging_range.webp"
alt="‚Ä¶then observe the range object in the Debugger" />
<figcaption aria-hidden="true">‚Ä¶then observe the range object in the
Debugger</figcaption>
</figure>
<h3 id="whats-a-text-node">What‚Äôs a #text node?</h3>
<p>An HTML element, like a <code>&lt;p&gt;</code> element, can contain
more than just text. It can also contain inline content elements like
<code>&lt;img&gt;</code>, <code>&lt;input&gt;</code> or
<code>&lt;select&gt;</code>, or inline formatting elements like
<code>&lt;i&gt;</code> and <code>&lt;b&gt;</code>. Everything between
these inline elements, and all text inside them, is treated as a
<em>text node</em>. Even the gaps between HTML elements in the HTML page
are considered to be text nodes. Here‚Äôs an example. All the highlighted
characters in the HTML code below are in text nodes, including the
invisible spaces and carriage returns.</p>
<pre class="language-html"><code class="language-html"><i><u>  </u>&lt;p&gt;<u>‚Üµ
    </u>&lt;span&gt;<u>text node in a child span</u>&lt;/span&gt;<u>‚Üµ
    text node in the top-level paragraph‚Üµ
    </u>&lt;code&gt;<u>text node in a code block</u>&lt;/code&gt;<u>‚Üµ</u>
<u>  </u>&lt;/p&gt;</i></code></pre>
<details class="alert" open>
<summary>
White space
</summary>
<p>By default, all consecutive white space in text nodes is collapsed
into a single space (<code></code>) character, so you may not be aware
of how much white space there actually is. But you will need to pay
attention: soon you‚Äôll be having to count every last white space
character, if you want to get your text selection tool to work well.</p>
<p>Notice, for example, how this line in your HTML file contains seven
spaces between ‚Äúdrag‚Äù and ‚Äúto‚Äù‚Ä¶</p>
<pre class="language-html line-numbers" data-start="48"><code class="language-html line-numbers">  &lt;p id="one"&gt;Click and drag       to make a selection üëçüèº&lt;/p&gt;</code></pre>
<p>‚Ä¶ but when this line is rendered in the page, it shows only one:</p>
<figure>
<img src="images/one_space.webp"
alt="Only one space rendered between ‚Äúdrag‚Äù and ‚Äúto‚Äù" />
<figcaption aria-hidden="true">Only one space <em>rendered</em> between
‚Äúdrag‚Äù and ‚Äúto‚Äù</figcaption>
</figure>
</details>
<h3 id="startoffset-and-endoffset">startOffset and endOffset</h3>
<p>When the word ‚ÄòClick‚Äô is selected, the <code>startOffset</code> is
<code>0</code> while the <code>endOffset</code> is set to
<code>5</code>.</p>
<p>You should be used to JavaScript counting from 0, so this should make
good sense to you. Here, the <code>startOffset</code> is saying that
your selection starts when there are 0 characters to the left in the
<code>startContainer</code>, and the <code>endOffset</code> shows that
after the 5-letter word ‚ÄòClick‚Äô, there are 5 characters <i>to the
left</i> in the <code>endContainer</code>‚Ä¶ which in this case is exactly
the same as <code>startContainer</code>.</p>
<details class="note" open>
<summary>
<code>endOffset</code> is exclusive
</summary>
<p>An <code>endOffset</code> of <code>5</code> tells you that
<code>"Click and drag..."[5]</code> (the character at index 5) is
<strong>not</strong> included ind the selection.
<code>"Click and drag..."[5]</code> refers to the <em>space</em> after
the end of the word <code>Click</code>, and not the ‚Äúk‚Äù, which is at
index <code>4</code>.</p>
<p><code>endOffset</code> in <em>exclusive</em>. It always refers to the
first character that is <strong>not</strong> included in the
selection.</p>
</details>
</section>
<!-- Counting White Space -->
<section id="counting-units" aria-labelledby="counting-units" data-item="Counting Units">
<h2>
<a href="#counting-units">Counting Units</a>
</h2>
<p>Time for another experiment. In the demo you used earlier (or in the
version you created for yourself), select from the last letter of ‚Äúdrag‚Äù
to the first letter of ‚Äúto‚Äù.</p>
<figure>
<img src="images/22-13.webp"
alt="One visual space can be many HTML white space characterss" />
<figcaption aria-hidden="true">One visual space can be many HTML white
space characterss</figcaption>
</figure>
<p>On the page, it looks like there is only one space between the start
of the letter ‚Äúg‚Äù in ‚Äúdrag‚Äù and the end of the letter ‚Äút‚Äù in ‚Äútwo‚Äù. But
the <code>range</code> object is looking at the source HTML, and it
keeps a different score. It counts one letter ‚Äúg‚Äù, then seven spaces,
and then one letter ‚Äút‚Äù ‚Äî a difference of 9:</p>
<h3 id="when-a-character-is-more-than-it-appears-to-be">When a character
is more than it appears to be</h3>
<p>Third experiment: select the emoji üëçüèº and check what the values are
for <code>startOffset</code> and <code>endOffset</code>.</p>
<figure>
<img src="images/emoji_selected.webp"
alt="An emoji can count as several characters" />
<figcaption aria-hidden="true">An emoji can count as several
characters</figcaption>
</figure>
<p>Surprised? The demo shows that <code>startOffset</code> is 41 and
<code>endOffset</code> is 45. That suggest that the üëçüèº is four
characters long, but it only takes up one place.</p>
<h3 id="utf-16-units">UTF-16 units</h3>
<p>Computing as we know it today first started in the English-speaking
world. In English, there are 26 letters (a-z), with 52 different signs
for UPPERCASE and lowercase, plus ten digits (0-9), plus a few
punctuations marks like <code>,;;.!?()/%$¬£#'"- ‚Äî‚Ä¶</code>, and of course,
the space. All these characters could be given numbers, with the highest
number staying below 127. By coincidence, the number 127 in decimal is
1111111 in the binary system, and binary numbers are conveniently
bundled in groups of 8 bits, so everything was perfect, and it was
called ASCII. <em>American Standard Code for Information
Interchange</em>.</p>
<p>And this was perfect, at least, for people using the same Latin
alphabet as English.</p>
<p>But there is not just English in the world. There are many different
writing scripts, like Arabic and the Indian Devanagari script, not to
mention languages like Chinese which contain thousands of individual
pictograms. To enable computers to handle all the thousands of different
written symbols, the system of giving each symbol a number had to be
extended.</p>
<p>One standard now is <a
href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a>, which has
variable-length blocks from 8 to 32 bits, and which provides enough
numbers to label the 1,112,064 different symbols from many different
languages that are recognized today. And it turns out that UTF-16 still
has a few numbers left over, and these are now being used for
emojis.</p>
<p>So you might imagine that an emoji would take two character spaces,
where English letters, numbers and punctuation take only one. But that
is politically incorrect. Emojis that show humans and parts of humans
can have different skin colours, so the üëçüèº emoji takes two values: a
generic thumbs-up plus a skin colour.</p>
<p>To cut a long story short: <code>startOffset</code> and
<code>endOffset</code> do not count characters or bits or bytes. They
count <code>UTF-16 units</code>, and the üëçüèº emoji uses four UTF-16
units.</p>
<p>From now on, I‚Äôll just call them <code>units</code>, and you‚Äôll
discover later just how important it is to think in <em>units</em>
rather than <em>characters</em> when working in with other languages
(and with emojis).</p>
<details class="note" open>
<summary>
Units and Spaces
</summary>
<p>The important point to note is that the Selection and Range objects
use a different system for counting where a selection starts and
finishes than the one that might seem familiar to you.</p>
<p>So now you know, and you can start to think about selections with
this new mental image.</p>
</details>
</section>
<!-- Different Containers -->
<!-- Role of Text Nodes -->
<section id="role-of-text-nodes" aria-labelledby="role-of-text-nodes" data-item="The Role of Text Nodes">
<h2>
<a href="#role-of-text-nodes">The Role of Text Nodes</a>
</h2>
<p>So far, the only selections we have looked at together have started
and ended in the same container. How is a selection represented when it
starts in one HTML element and finishes in another?</p>
<p>Let‚Äôs start with two simple cases. For the first case, click in the
line at the top and drag your mouse down, so that the selection starts
in the first <code>&lt;p&gt;</code> element and ends in the second
<code>&lt;p&gt;</code> element:</p>
<pre class="language-html line-numbers" data-start="46"><code class="language-html line-numbers"><i>    &lt;p id="one"&gt;Click and drag<u>       to make a selection üëçüèº&lt;/p&gt;
    &lt;p id="two"&gt;Your selection </u>can &lt;i&gt;start&lt;/i&gt; on one
    line and &lt;i&gt;end&lt;/i&gt; on another.&lt;/p&gt;</i></code></pre>
<figure>
<img src="images/two_lines.webp"
alt="When startContainer and endContainer are different" />
<figcaption aria-hidden="true">When startContainer and endContainer are
different</figcaption>
</figure>
<p>Note that <code>startOffset</code> gives you the number of units from
the beginning of the text node in the <code>&lt;p id="one"&gt;</code>
paragraph, and that <code>endOffset</code> gives you the number of units
from the beginning of the text node in the
<code>&lt;p id="two"&gt;</code> paragraph. Both of these containers are
identified with the <code>nodeName</code> <code>#text</code>, but the
identity of their <code>.parentElement</code> distinguishes them.</p>
<p>Specifically, notice that neither offset is measured from the
beginning of the page. Each of them is relative to their container.</p>
<h3 id="nested-containers">Nested containers</h3>
<p>Here‚Äôs the second simple case to test. Click somewhere inside the
word ‚Äústart‚Äù (in <i>italics</i>), and drag the selection to somewhere
outside the word, where the text is no longer in italics.</p>
<pre class="language-html line-numbers" data-start="47"><code class="language-html line-numbers"><i>    &lt;p id="two"&gt;Your selection </u>can &lt;i&gt;s<u>tart&lt;/i&gt; on one
    line</u> and &lt;i&gt;end&lt;/i&gt; on another.&lt;/p&gt;</i></code></pre>
<figure>
<img src="images/start_in_i_tag.webp"
alt="Container.parentElements of different types" />
<figcaption aria-hidden="true">Container.parentElements of different
types</figcaption>
</figure>
<p>Note that the <code>startContainer</code>‚Äôs
<code>parentElement</code> is now reported as an <code>i</code> element,
while the <code>endContainer</code>‚Äôs <code>parentElement</code> is
reported as <code>p#two</code>. The <code>&lt;p id="two"&gt;</code>
paragraph has several top-level text nodes, separated by the text nodes
inside the <code>&lt;i&gt;</code> tags, as the image below
illustrates:</p>
<pre class="language-html"><code class="language-html">&lt;p&gt;<u>text node</u>&lt;i&gt;<u>text node</u>&lt;/i&gt;<u>text node</u>&lt;i&gt;<u>text node</u>&lt;/i&gt;<u>text node</u>&lt;/p&gt;</code></pre>
<details class="note" open>
<summary>
Respect for #text nodes
</summary>
<p>In every case, <code>startOffset</code> and <code>endOffset</code>
are calculated <em>from the beginning of the specific text node</em> in
which they occur.</p>
<p>Be sure to note that the <code>parentElement</code> only helps
identify where a given text node occurs, but its position and the length
of its text are never used to <code>startOffset</code> and
<code>endOffset</code>.</p>
</details>
</section>
<!-- Browser Differences -->
<section id="browser-differences" aria-labelledby="browser-differences" data-item="Browser Differences">
<h2>
<a href="#browser-differences">Edge Cases and Browser Differences</a>
</h2>
<p>Earlier, I wrote that you would look at two simple cases. Here‚Äôs a
third case, but it turns out not to be simple at all. The results you
get will depend on which browser you are using, and even how you make
the selection.</p>
<p>Select the words ‚Äú<em>start</em> on one line and <em>end</em>‚Äù,
making sure that the selection begins with the whole word
‚Äú<em>start</em>‚Äù and ends with the whole word ‚Äú<em>end</em>‚Äù.</p>
<p>But try different ways of making this selection:</p>
<ul>
<li>Drag from the beginning of the word ‚Äú<em>start</em>‚Äù to the end of
the word ‚Äú<em>end</em>‚Äù</li>
<li>Double click on the word ‚Äú<em>start</em>‚Äù then press Shift and click
after the word ‚Äú<em>end</em>‚Äù</li>
<li>Select from the beginning of the word ‚Äú<em>start</em>‚Äù to somewhere
in the middle of the word ‚Äú<em>end</em>‚Äù, then use Shift+Right Arrow to
extend the selection to the end of the word ‚Äú<em>end</em>‚Äù</li>
<li>Select from the end of the word ‚Äú<em>end</em>‚Äù to somewhere in the
middle of the word ‚Äú<em>start</em>‚Äù, then use Shift+Left Arrow to extend
the selection to the end of the word ‚Äú<em>start</em>‚Äù</li>
<li>‚Ä¶</li>
</ul>
<p>Try doing this in different browsers. Here are some of the ways the
<code>range</code> values may be set:</p>
<hr />
<pre class="language-html"><code class="language-html">... can &lt;i&gt;<u>start&lt;/i&gt; on one line and &lt;i&gt;end</u>&lt;/i&gt; on...</code></pre>
<figure>
<img src="images/chrome.webp" alt="i 0 to i 3 on Chrome" />
<figcaption aria-hidden="true"><em>i 0</em> to <em>i 3</em> on
Chrome</figcaption>
</figure>
<hr />
<pre class="language-html"><code class="language-html">... can <u>&lt;i&gt;start&lt;/i&gt; on one line and &lt;i&gt;end</u>&lt;/i&gt; on...</code></pre>
<figure>
<img src="images/safari.webp" alt="p#two 19 to i 3 on Safari" />
<figcaption aria-hidden="true"><em>p#two 19</em> to <em>i 3</em> on
Safari</figcaption>
</figure>
<hr />
<pre class="language-html"><code class="language-html">... can &lt;i&gt;<u>start&lt;/i&gt; on one line and &lt;i&gt;end&lt;/i&gt;</u> on...</code></pre>
<figure>
<img src="images/firefox.webp" alt="i 0 to p#two 0 on Firefox" />
<figcaption aria-hidden="true"><em>i 0</em> to <em>p#two 0</em> on
Firefox</figcaption>
</figure>
<hr />
<p>Selections that look exactly the same on the screen may be described
differently by the <code>range</code> object, when the selection
boundary is at the boundary between two containers. All of these
descriptions are correct, but they all have slightly different
meanings.</p>
<p>And try this: double-click on the üëçüèº emoji at the end of
<code>&lt;p id="one"&gt;</code>, then press Shift+Right Arrow.</p>
<figure>
<img src="images/double_click_emoji.webp"
alt="Double click to select the emoji‚Ä¶" />
<figcaption aria-hidden="true">Double click to select the
emoji‚Ä¶</figcaption>
</figure>
<figure>
<img src="images/Shift_Right_Arrow.webp"
alt="‚Ä¶ then press Shift+Right arrow to extend the selection" />
<figcaption aria-hidden="true">‚Ä¶ then press Shift+Right arrow to extend
the selection</figcaption>
</figure>
<p>The visual appearance of the selection will not change, but the
<code>range</code> object will now see that you have extended the
selection to include the invisible carriage return and white space
characters between the two <code>&lt;p&gt;</code> elements.</p>
<pre class="language-html line-numbers" data-start="48"><code class="language-html line-numbers">  &lt;p id="one"&gt;Click and drag       to make a selection üëçüèº&lt;/p&gt;<u>‚Üµ  
  </u>&lt;p id="two"&gt;Your selection can &lt;i&gt;start&lt;/i&gt; on one line and</code></pre>
<h3 id="need-to-normalize">Need to Normalize</h3>
<p>The point to note here is that you cannot trust the Selection data
blindly. You will need to <em>normalize</em> a selection to a specific,
known state, before you start to work with it. Precisely how you
normalize it will depend on how you plan to work with it.</p>
<p>For example, suppose you have text like this:</p>
<blockquote>
<p>Compare <em>short</em>-term and <em>long</em>-term planning</p>
</blockquote>
<p>And suppose one of your end-users makes a partial selection, like
this:</p>
<pre class="language-html"><code class="language-html">Compare &lt;i&gt;short&lt;i&gt;<u>-term and &lt;i&gt;long</u>&lt;i&gt;-term planning</code></pre>
<p>If your app is designed to ensure that whole words are selected, it
will need to change the initial selection to this:</p>
<pre class="language-html"><code class="language-html">Compare <u>&lt;i&gt;short&lt;i&gt;-term and &lt;i&gt;long&lt;i&gt;-term</u> planning</code></pre>
<p>In this case, you will want your app to normalize the start and the
end of the selection in different ways:</p>
<ul>
<li>You want to normalize the start of the selection to begin at the end
of the first &lt;i&gt; tag, so that your app can extend the start
backwards, to add ‚Äú<em>short</em>‚Äù to the word ‚Äú-term‚Äù</li>
<li>You want to normalzie the end of the selection to the beginning of
the text node following the closing &lt;/i&gt; tag, so that your app can
extend the end forwards, to add ‚Äúterm‚Äù to the word ‚Äú<em>long</em>‚Äù.</li>
</ul>
<p>In other words, here‚Äôs how your app would need to normalize the
user‚Äôs selection before using it to extend to include whole words:</p>
<pre class="language-html"><code class="language-html">Compare &lt;i&gt;short<u>&lt;i&gt;-term and &lt;i&gt;long&lt;i&gt;</u>-term planning</code></pre>
<p>Other cases might require different normalization techniques.</p>
<details class="note" open>
<summary>
The lesson to learn here
</summary>
<p>Sometimes you will need to <strong>adjust the raw selection
data</strong> that the browser gives you, so that you can use the
selection the way you want to use it.</p>
</details>
</section>
<!-- Other Selection States -->
<section id="other-selection-states" aria-labelledby="other-selection-states" data-item="Other Selection Cases">
<h2>
<a href="#other-selection-states">Other Selection Cases</a>
</h2>
<h3 id="a-collapsed-selection">A collapsed Selection</h3>
<p>As you saw earlier, before you make your first click on a
newly-opened web page, the Selection object already exists but it does
not yet contain any Range objects. After the first Range object has been
created, a simple click on the page will deselect all text, but the
Range object will continue to exist. No selection will be visible on the
page.</p>
<p>After a simple click, the Selection will simply set its
<code>isCollapsed</code> property to <code>true</code>, the
<code>startOffset</code> and <code>endOffset</code> will be set to the
same numerical value, and the <code>startContainer</code> and
<code>endContainer</code> will both refer to the same text node.</p>
<p>Try clicking on the demo page in different places.</p>
<figure>
<img src="images/invisible_caret.webp"
alt="A click collapses the Selection to an invisible caret" />
<figcaption aria-hidden="true">A click collapses the Selection to an
invisible caret</figcaption>
</figure>
<figure>
<img src="images/isCollapsed.webp" alt="When a Selection isCollapsed" />
<figcaption aria-hidden="true">When a Selection isCollapsed</figcaption>
</figure>
<p>If you click outside any text content, the Selection will still be
collapsed, but the range will not be a text node:</p>
<figure>
<img src="images/all_deselected.webp"
alt="A click to the right of the input field, not in a text node" />
<figcaption aria-hidden="true">A click to the right of the input field,
not in a text node</figcaption>
</figure>
<details class="note" open>
<summary>
Selection.isCollapsed
</summary>
<p>When there is no visible selection in the page:</p>
<ul>
<li>The Selection‚Äôs‚Äô <code>isCollapsed</code> property will be set to
<code>true</code></li>
<li>The <code>startOffset</code> and <code>endOffset</code> will be set
to the same numerical value</li>
<li>The <code>startContainer</code> and <code>endContainer</code> will
both refer to the same text node.</li>
</ul>
</details>
<h3 id="a-selection-with-no-range-object">A Selection with no Range
object</h3>
<p>It‚Äôs possible to destroy the Range object, by selecting something
that the Selection object can‚Äôt directly see. Try typing some text into
the <code>&lt;input type="text"&gt;</code> field, and then select some
of your input text.</p>
<figure>
<img src="images/input_selected0.webp"
alt="The Selection can‚Äôt see text in &lt;input&gt; elements‚Ä¶" />
<figcaption aria-hidden="true">The Selection can‚Äôt see text in
<code>&lt;input&gt;</code> elements‚Ä¶</figcaption>
</figure>
<p>But perhaps you see something different? Perhaps you see that
<code>selection.toString()</code> does indeed show the text that you
selected in the input field:</p>
<figure>
<img src="images/input_selected1.webp" alt="‚Ä¶ or can it?" />
<figcaption aria-hidden="true">‚Ä¶ or can it?</figcaption>
</figure>
<p>This depends on which browser you are using, and whether the
selection that you made just before was collapsed or not.</p>
<details class="note" open>
<summary>
Selection inside an <code>&lt;input type="text"&gt;</code> field
</summary>
<p>The result of selecting inside an
<code>&lt;input type="text"&gt;</code> field is not well-defined.</p>
<p>Depending on the browser and your most recent selection, selecting
text inside an <code>&lt;input type="text"&gt;</code> field can
either:</p>
<ul>
<li>Destroy the Selection‚Äôs Range object</li>
<li>Provide a unexpected value for the <code>startContainer</code> and
<code>endContainer</code>, and display the text selected in the
<code>&lt;input type="text"&gt;</code> field as
<code>Selection.toString()</code></li>
</ul>
</details>
<h3 id="browser-differences-when-you-select-all">Browser differences
when you Select All</h3>
<p>WHen you user the Menu item Edit &gt; Select All, or the
corresponding keyboard shortcut, different browsers will display the
selection differently on the page, and Selection.toString() may have
different values.</p>
<p>Chrome and Edge mostly agree; Safari also highlights empty space to
the left. Firefox does things differently:</p>
<ul>
<li>Firefox includes invisible carriage returns known only to the
HTML</li>
<li>Firefox does not highlight text in an
<code>&lt;input type="text"&gt;</code> field</li>
<li>Firefox includes the <em>alt</em> text of an image in
Selection.string()</li>
</ul>
<p>All browsers agree, though, <strong>not</strong> to include:</p>
<ul>
<li>The text of <code>::before</code> and <code>::after</code> and other
pseudo-elements</li>
<li>Elements with the CSS rule: <code>{ user-select: none }</code></li>
</ul>
<figure>
<img src="images/select_all_chrome.webp" alt="Select All on Chrome" />
<figcaption aria-hidden="true">Select All on Chrome</figcaption>
</figure>
<figure>
<img src="images/select_all_safari.webp" alt="Select All on Safari" />
<figcaption aria-hidden="true">Select All on Safari</figcaption>
</figure>
<figure>
<img src="images/select_all_edge.webp" alt="Select All on Edge" />
<figcaption aria-hidden="true">Select All on Edge</figcaption>
</figure>
<figure>
<img src="images/select_all_firefox.webp" alt="Select All on Firefox" />
<figcaption aria-hidden="true">Select All on Firefox</figcaption>
</figure>
<details class="alert" open>
<summary>
Test early, test often, test on all target browsers
</summary>
<p>You probably don‚Äôt need to be reminded of this, but you can‚Äôt trust
all browsers to behave the same way, and you need to make sure that your
code is working exactly the way you expect on all the browsers that you
end-users are likely to use.</p>
</details>
</section>
<!-- Word Boundaries -->
<section id="word-boundaries" aria-labelledby="word-boundaries" data-item="Word Boundaries">
<h2>
<a href="#word-boundaries">Word Boundaries</a>
</h2>
<p>Where does one word end and the next word begin?</p>
<p>Since your early childhood, you have been able to detect word
boundaries in spoken speech. Try asking a two-year old to say
‚Äúspeedboat‚Äù. (Make sure you pronounce the ‚Äúd‚Äù.) The chances are that the
child will answer with two words, with a distinct gap between them:
‚Äúspeed ‚Ä¶ boat‚Äù. That‚Äôs because the sequence ‚Äúdb‚Äù is very unusual in
English words. Before children can say the words ‚Äústatistical
probability‚Äù, their brains are busy analysing the sounds they hear
according to statistical probability. And their brains tell them that
‚Äúdb‚Äù is very rare in the middle of a word, so it must be a word
break.</p>
<p>But how can a web browser do this?</p>
<h3 id="messing-with-white-space">Messing with white space</h3>
<p>You only need to take a quick glance at the two sentences below to
know that they are different, and that the words need to be pronounced
differently, possibly with a different accent:</p>
<blockquote>
<p>The irregular program mess ends now.</p>
<p>Their regular programmes send snow.</p>
</blockquote>
<p>But both sentences use the exact same letters in the exact same
order, and only the position of the spaces change. Your brain can
immediately see the differences, and may not even notice the similarity
until it is pointed out to you.</p>
<p>In this project, which aims to to ensure that every selection starts
and ends with a whole word, you‚Äôll somehow need to explain to your
browser what a whole word is, even when there are HTML tags to confuse
it.</p>
<p>Does the following HTML seem clear to you, now, even when you know
what you are looking for?</p>
<pre class="language-html wrap"><code class="language-html wrap">&lt;p id="source"&gt;&lt;i class="after"&gt;The&lt;u&gt; &lt;/u&gt;ir&lt;/i&gt;&lt;b&gt;regular program&lt;u&gt; &lt;/u&gt;mes&lt;/b&gt;&lt;i class="before after"&gt;s&lt;u class="space"&gt; &lt;/u&gt;end&lt;/i&gt;s&lt;u class="space"&gt; &lt;/u&gt;now.&lt;/p&gt;</code></pre>
<h3 id="enter-intl.segmenter">Enter <code>Intl.Segmenter</code></h3>
<p>A new API was <a
href="https://caniuse.com/?search=Intl.Segmenter">recently</a> added to
JavaScript as a global object in all major browsers: <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter">Intl.Segmenter</a>.</p>
<details class="warn" open>
<summary>
Work in Progress
</summary>
<p>At the time of writing, Intl.Segmenter is still not doing everything
that is planned for it to do. By the time you read this, it may have
improved. You might find that some of the limitations I describe here no
longer cause any problems.</p>
</details>
<p>Below is a demo that uses the Intl.Segmenter to parse the text of the
HTML chunk just above. Here is a simplified version of the code that
creates the segment objects that you see in the demo:</p>
<pre class="language-javascript"><code class="language-javascript">      const source = document.getElementById("source");
      const text = source.textContent;

      const lang = "en";
      const options = { granularity: "word" };
      const segmenter = new Intl.Segmenter(lang, options);
      const segments = Array.from(segmenter.segment(text));</code></pre>
<p>Note that you need to tell the Intl.Segmenter instance what
<code>lang</code>uage the input is going to be in, and what
<code>granularity</code> you want to use. For language, it makes sense
to use ‚Äúen‚Äù (for English).</p>
<p>The values for <code>granularity</code> are <em>grapheme</em>,
<em>word</em> and <em>sentence</em>. In English, using <em>grapheme</em>
will split your text into individual characters: each letter, space and
punctuation mark will be treated separately. When dealing with emoji or
certain other writing systems, a grapheme corresponds to a single visual
item which is never divided into its constituent parts.</p>
<p>If you click on the checkbox in the green section at the top, a
series of rules are applied to the different <code>&lt;i&gt;</code> and
<code>&lt;u&gt;</code> blocks within the HTML chunk shown above. This
will force the text to <em>appear</em> differently in the browser. The
HTML itself does not change.</p>
<p>However, the Intl.Segmenter ignores all the formatting, and just
reads the raw <code>textContent</code> of the
<code>&lt;p id="source"&gt;</code> element. As a result, as you can see,
it produces exactly the same <code>segments</code> whether the checkbox
is checked on not.</p>
<iframe id="intl-segmenter-demo" title="intl-segmenter" width="480" height="800" src="https://merncraft.github.io/Intl-Segmenter">
</iframe>
<details class="tldr">
<summary>
Try This at Home
</summary>
<p>To create the same demo on your own computer, you can clone the <a
href="https://github.com/MERNCraft/Intl-Segmenter">GitHub
repository</a>, or follow the instructions below.</p>
<ol type="1">
<li>Greate a file called <code>Intl_Segmenter.html</code></li>
<li>Copy and paste the HTML shown below into it</li>
<li>Open the file in your Browser</li>
</ol>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;Word Boundaries&lt;/title&gt;
    &lt;style&gt;
      body {
        display: flex;
        flex-direction: column;
        margin: 0;
        height: 100vh;
        color: #ddd;
        background-color: #111;

        & div#settings {
          background-color: #060;
          padding: 0 1em 1em;

          #use-css {
            opacity: 0.5;
            pointer-events: none;

            &.active {
              opacity: 1;
              pointer-events: all;
            }
          }

          & &gt; label,
          & details &gt; label {
            display: block;
            width: 100%;
            text-align: center;
            margin-top: 1em;
          }

          & details {
            & div {
              text-align: center;
              margin-top: 1em;

              &.language {
                display: flex;
                justify-content: center;
                align-items: center;

                input[type=radio] {
                  position: absolute;
                  left: -999vw;

                  &:checked ~ img {
                    opacity: 1;
                    border-color: white;
                    box-shadow: 0 0 10px white;
                  }
                }
                & label img {
                  width: 1.5em;
                  margin-left: 0.5em;
                  opacity: 0.75;
                  border: 1px solid transparent;
                  border-radius: 1em;
                }
              }
            }
          }
        }


        & p[lang] {
          font-size: 1.2em;
          color: #0c0;
          text-align: center;
          display: none;
        }

        u {
          text-decoration: none;
        }

        &:has(#checkbox:checked) {
          & #source {
            color: #c00;

            /* use non-breaking spaces to force letters apart */
            i.after {
              &::after {
                content: "\00A0";
                display: inline-block;
              }
            }
            i.before::before {
              content: "\00A0";
              display: inline-block;
            }
            u {
              font-size: 0;
            }
          }
        }

        #segments {
          flex: 1;
          overflow-y: auto;
        }

        pre {
          white-space: pre-wrap;

          &::first-line {
            font-size: 1.5em;
          }
        }

        #identical {
          color: #0c0;
          text-align: center;

          &:empty {
            display: none;
          }
        }
      }

      .selected {
        display: block!important
      }
    &lt;/style&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div id="settings"&gt;
      &lt;label id="use-css"&gt;
        &lt;span&gt;Use CSS to change the spacing:&lt;/span&gt;
        &lt;input type="checkbox" id="checkbox"&gt;
      &lt;/label&gt;

      &lt;details id="details"&gt;
        &lt;summary&gt;More&lt;/summary&gt;

        &lt;div class="language"&gt;
          &lt;span&gt;Text in:&lt;/span&gt;
          &lt;label&gt;
            &lt;input type="radio" name="language" id="en" checked&gt;
            &lt;img src="images/en-GB.png" checked alt="English" title="English"&gt;
          &lt;/label&gt;
          &lt;label&gt;
            &lt;input type="radio" name="language" id="am" &gt;
            &lt;img src="images/am.png" alt="·ä†·àõ·à≠·äõ" title="·ä†·àõ·à≠·äõ Amharic"&gt;
          &lt;/label&gt;
          &lt;label&gt;
            &lt;input type="radio" name="language" id="ar"&gt;
            &lt;img src="images/ar.png" alt="ÿπÿ±ÿ®Ÿä" title="ÿπÿ±ÿ®Ÿä Arabic"&gt;
          &lt;/label&gt;
          &lt;label&gt;
            &lt;input type="radio" name="language" id="bn"&gt;
            &lt;img src="images/bn.png" alt="‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ" title="‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ Bengali"&gt;
          &lt;/label&gt;
          &lt;label&gt;
            &lt;input type="radio" name="language" id="fr"&gt;
            &lt;img src="images/fr-FR.png" alt="Fran√ßais" title="Fran√ßais French"&gt;
          &lt;/label&gt;
          &lt;label&gt;
            &lt;input type="radio" name="language" id="hi"&gt;
            &lt;img src="images/hi.png" alt="‡§π‡§ø‡§Ç‡§¶‡•Ä" title="‡§π‡§ø‡§Ç‡§¶‡•Ä Hindi"&gt;
          &lt;/label&gt;
          &lt;label&gt;
            &lt;input type="radio" name="language" id="iu"&gt;
            &lt;img src="images/iu.png" alt="·êÉ·ìÑ·íÉ·ëé·ëê·ë¶" title="·êÉ·ìÑ·íÉ·ëé·ëê·ë¶ Inuktut"&gt;
          &lt;/label&gt;
          &lt;label&gt;
            &lt;input type="radio" name="language" id="ja"&gt;
            &lt;img src="images/ja.png" alt="Êó•Êú¨Ë™û" title="Êó•Êú¨Ë™û Japanese"&gt;
          &lt;/label&gt;
          &lt;label&gt;
            &lt;input type="radio" name="language" id="ko"&gt;
            &lt;img src="images/ko.png" alt="ÌïúÍµ≠Ïù∏" title="ÌïúÍµ≠Ïù∏ Korean"&gt;
          &lt;/label&gt;
          &lt;label&gt;
            &lt;input type="radio" name="language" id="ru"&gt;
            &lt;img src="images/ru.png" alt="–†—É—Å—Å–∫–∏–π" title="–†—É—Å—Å–∫–∏–π Russian"&gt;
          &lt;/label&gt;
          &lt;label&gt;
            &lt;input type="radio" name="language" id="ta"&gt;
            &lt;img src="images/ta.png" alt="‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç" title="‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç Tamil"&gt;
          &lt;/label&gt;
          &lt;label&gt;
            &lt;input type="radio" name="language" id="th"&gt;
            &lt;img src="images/th.png" alt="‡πÑ‡∏ó‡∏¢" title="‡πÑ‡∏ó‡∏¢ Thai"&gt;
          &lt;/label&gt;
        &lt;/div&gt;

        &lt;div class="options"&gt;
          new Intl.Segmenter ({
          &lt;label&gt;
            &lt;span&gt;lang:&lt;/span&gt;
            &lt;select id="lang"&gt;
              &lt;option value="en" selected&gt;en&lt;/option&gt;
              &lt;option value="am"&gt;am&lt;/option&gt;
              &lt;option value="ar"&gt;ar&lt;/option&gt;
              &lt;option value="bn"&gt;bn&lt;/option&gt;
              &lt;option value="fr"&gt;fr&lt;/option&gt;
              &lt;option value="hi"&gt;hi&lt;/option&gt;
              &lt;option value="ja"&gt;ja&lt;/option&gt;
              &lt;option value="ko"&gt;ko&lt;/option&gt;
              &lt;option value="iu"&gt;iu&lt;/option&gt;
              &lt;option value="ru"&gt;ru&lt;/option&gt;
              &lt;option value="ta"&gt;ta&lt;/option&gt;
              &lt;option value="th"&gt;th&lt;/option&gt;
            &lt;/select&gt;
          &lt;/label&gt;
          ,
          &lt;label&gt;
            &lt;span&gt;granularity:&lt;/span&gt;
            &lt;select id="granularity"&gt;
              &lt;option value="grapheme"&gt;grapheme&lt;/option&gt;
              &lt;option value="word" selected&gt;word&lt;/option&gt;
              &lt;option value="sentence"&gt;sentence&lt;/option&gt;
            &lt;/select&gt;
          &lt;/label&gt;
          })
        &lt;/div&gt;

        &lt;label&gt;
          &lt;span&gt;Compare segmentation across all languages&lt;/span&gt;
          &lt;input type="checkbox" id="check-all"&gt;
        &lt;/label&gt;
      &lt;/details&gt;
    &lt;/div&gt;
    &lt;p id="source" lang="en" class="selected"&gt;&lt;i class="after"&gt;The<u> </u>ir</i><b>regular program<u> </u>mes</b>&lt;i class="before after"&gt;s&lt;u class="space"&gt; </u>end</i>s&lt;u class="space"&gt; </u>now.&lt;/p&gt;
    &lt;p lang="am"&gt;·ä†·àõ·à≠·äõ ·ç° ·ã®·ä¢·âµ·ãÆ·åµ·ã´ ·ç° ·àò·ã∞·â†·äõ ·ç° ·âã·äï·âã ·ç° ·äê·ãç ·ç¢ ·à¥·àõ·ãä ·ç° ·âã·äï·âã·ãé·âΩ ·ç° ·ãç·àµ·å• ·ç° ·ã®·àö·àò·ã∞·â• ·ç° ·à≤·àÜ·äï ·ç° ·ä´·à®·â¢·äõ ·ç° ·âÄ·å•·àé ·ç° ·àÅ·àà·â∞·äõ ·ç° ·â•·ãô ·ç° ·â∞·äì·åã·à™·ãé·âΩ ·ç°&lt;/p&gt;
    &lt;p lang="ar"&gt;ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ŸÑÿ∫ÿ©Ÿå ÿ±ÿ≥ŸÖŸäÿ© ŸÅŸä ŸÉŸÑ ÿØŸàŸÑ ÿßŸÑŸàÿ∑ŸÜ ÿßŸÑÿπÿ±ÿ®Ÿä&lt;/p&gt;
    &lt;p lang="bn"&gt;‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶∏‡¶æ‡¶∞‡ßç‡¶¨‡¶≠‡ßå‡¶Æ ‡¶≠‡¶æ‡¶∑‡¶æ‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï ‡¶ú‡¶æ‡¶§‡¶ø‡¶∞‡¶æ‡¶∑‡ßç‡¶ü‡ßç‡¶∞ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶è‡¶ï‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶∞‡¶æ‡¶∑‡ßç‡¶ü‡ßç‡¶∞‡¶≠‡¶æ‡¶∑‡¶æ ‡¶§‡¶•‡¶æ ‡¶∏‡¶∞‡¶ï‡¶æ‡¶∞‡¶ø ‡¶≠‡¶æ‡¶∑‡¶æ‡•§&lt;/p&gt;
    &lt;p lang="fr"&gt;Les premi√®res occurrences du mot ¬´ France ¬ª en langue fran√ßaise se rencontrent au XIe si√®cle.&lt;/p&gt;
    &lt;p lang="hi"&gt;‡§π‡§ø‡§®‡•ç‡§¶‡•Ä ‡§∏‡§Ç‡§µ‡•à‡§ß‡§æ‡§®‡§ø‡§ï ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§≠‡§æ‡§∞‡§§ ‡§ï‡•Ä ‡§∞‡§æ‡§ú‡§≠‡§æ‡§∑‡§æ ‡§î‡§∞ ‡§≠‡§æ‡§∞‡§§ ‡§ï‡•Ä ‡§∏‡§¨‡§∏‡•á ‡§Ö‡§ß‡§ø‡§ï ‡§¨‡•ã‡§≤‡•Ä ‡§î‡§∞ ‡§∏‡§Æ‡§ù‡•Ä ‡§ú‡§æ‡§®‡•á ‡§µ‡§æ‡§≤‡•Ä ‡§≠‡§æ‡§∑‡§æ ‡§π‡•à‡•§&lt;/p&gt;
    &lt;p lang="ja"&gt;Êó•Êú¨„Å´„Åä„ÅÑ„Å¶„ÄÅÂõΩÂè∑„ÇíÁõ¥Êé•„Åã„Å§ÊòéÁ¢∫„Å´Ë¶èÂÆö„Åó„ÅüÊ≥ï‰ª§„ÅØÂ≠òÂú®„Åó„Å™„ÅÑ„ÄÇ&lt;/p&gt;
    &lt;p lang="ko"&gt;ÌïúÍµ≠Ïñ¥(ÈüìÂúãË™û) ÎòêÎäî Ï°∞ÏÑ†Ïñ¥(ÊúùÈÆÆË™û)Îäî ÎåÄÌïúÎØºÍµ≠Í≥º Ï°∞ÏÑ†ÎØºÏ£ºÏ£ºÏùòÏù∏ÎØºÍ≥µÌôîÍµ≠Ïùò Í≥µÏö©Ïñ¥Ïù¥Îã§. ÎëòÏùÄ ÌëúÍ∏∞ÎÇò Î¨∏Î≤ï, ÎèôÏÇ¨ Ïñ¥ÎØ∏, ÌëúÌòÑÏóêÏÑú ÏïΩÍ∞ÑÏùò Ï∞®Ïù¥Í∞Ä ÏûàÎã§.&lt;/p&gt;
    &lt;p lang="iu"&gt;·êÉ·ìÖ·î™·ìï·í´·ë¶ ·êä·ìÇ·ñÖ·ëé·ïÜ·î™·ìï·í´·ë¶ ·êÉ·ìÖ·ìö·êÖ·ïê·í™·ëï ·êÉ·ì±·í™·ïê·ì±·ïê·ìö·ëé·íÉ ·êä·íª·í™·ìó ·êä·îæ·î®·êÖ·ñÉ·ëé·í¶·íÉ·ìó·ëé·íÉ ·ìÇ·ïê·ì±·êä·ñë·ìÇ·íÉ·ëØ·ë¶ ·êä·íª·í™·ìó ·ê±·î™·ìê·ìÄ·ëé·ëé·íç·ë¶.&lt;/p&gt;
    &lt;p lang="ru"&gt;–†–æ—Å—Å–∏—è ‚Äî –º–Ω–æ–≥–æ–Ω–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–æ —Å —à–∏—Ä–æ–∫–∏–º —ç—Ç–Ω–æ–∫—É–ª—å—Ç—É—Ä–Ω—ã–º –º–Ω–æ–≥–æ–æ–±—Ä–∞–∑–∏–µ–º.&lt;/p&gt;
    &lt;p lang="ta"&gt;‡Æ®‡Ææ‡Æ©‡Øç ‡Æ™‡Æ≥‡Øç‡Æ≥‡Æø‡Æï‡Øç‡Æï‡ØÅ‡Æö‡Øç ‡Æö‡ØÜ‡Æ©‡Øç‡Æ±‡ØÅ ‡Æµ‡Æ∞‡ØÅ‡Æï‡Æø‡Æ±‡Øá‡Æ©‡Øç.&lt;/p&gt;
    &lt;p lang="th"&gt;‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÑ‡∏ó‡∏¢‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏Å‡∏£‡πÄ‡∏Å‡∏∑‡∏≠‡∏ö 66 ‡∏•‡πâ‡∏≤‡∏ô‡∏Ñ‡∏ô ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì 513,115 ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Å‡∏¥‡πÇ‡∏•‡πÄ‡∏°‡∏ï‡∏£&lt;/p&gt;

    &lt;pre id="words"&gt;&lt;/pre&gt;
    &lt;p id="identical"&gt;&lt;/p&gt;
    &lt;pre id="segments"&gt;&lt;/pre&gt;


    &lt;script&gt;
      const useCSS = document.getElementById("use-css")
      const checkbox = document.getElementById("checkbox")
      const details = document.getElementById("details")
      const triggers = Array.from(
        document.querySelectorAll("[name=language]")
      )
      const checkAll = document.getElementById("check-all")
      const select = document.getElementById("lang")
      const granularity = document.getElementById("granularity")
      triggers.push(checkAll)
      triggers.push(select)
      triggers.push(granularity)

      const wordsPre = document.getElementById("words")
      const identical = document.getElementById("identical")
      const segmentsPre = document.getElementById("segments")
      const phrases = Array.from(
        document.querySelectorAll("p[lang]")
      )
      const langs = phrases.map(
        phrase =&gt; phrase.getAttribute("lang")
      )

      let languageId

      checkbox.addEventListener("change", segmentText)
      details.addEventListener("toggle", toggleDetails)
      triggers.forEach( trigger =&gt; {
        trigger.addEventListener("change", setLanguage)
      })


      function segmentText() {
        const selector = `p[lang=${languageId}]`
        const source = document.querySelector(selector)
        const text = source.textContent

        const lang = select.value
        const options = { granularity: granularity.value }
        const segmenter = new Intl.Segmenter(lang, options)
        const segments = Array.from(segmenter.segment(text))

        let items = segments
          .filter((item) =&gt; item.isWordLike)
          .map((item) =&gt; item.segment)

          if (items.length) {
          items = `words:
${JSON.stringify(items, null, "  ")}`
        } else {
          const count = segments.length
          const s = count === 1 ? "" : "s"
          items = `${segments.length} ${granularity.value}${s} found`
        }

        wordsPre.textContent = items
        segmentsPre.textContent = `segments:
${JSON.stringify(segments, null, "  ")}`

        if (checkAll.checked) {
          checkAllLanguageSettings(text)

        } else {
          identical.textContent = ""
        }
      }


      function checkAllLanguageSettings(text) {
        // Segment the current text using all values of lang
        const sets = langs.map( lang =&gt; {
          const options = { granularity: granularity.value }
          const segmenter = new Intl.Segmenter(lang, options)
          const segments = Array.from(segmenter.segment(text))
          segments.lang = lang

          return segments
        })

        // Pair each segmentation with one from a different lang
        const pairs = sets.reduce(( pairs, original, index) =&gt; {
          const compare =  (index)
            ? sets[index - 1]
            : sets[sets.length - 1]

            pairs.push([ original, compare ])
          return pairs
        }, [])

        // If every pair contains identical segmentations, then
        // all the segmentations are identical.
        const same = pairs.every(([ original, compare ]) =&gt; (
          JSON.stringify(original) === JSON.stringify(compare)
        ))

        identical.innerHTML = `Segmentation results with all language settings are: <b>${same ? "identical" : "different"}</b>`
      }


      function toggleDetails({ target }) {
        if (!target.open) {
          // When details or closed, stop checking all languages...
          checkAll.checked = false
          // ... check only English...
          select.value = "en"
          // ... segment into words...
          granularity.value = "word"
          // ... and select the English text...
          target = triggers[0]
          target.checked = true
          // ... just as it was after the page first loaded
          setLanguage({ target })
        }
      }


      function setLanguage({ target }) {
        const { id, tagName } = target
        if ( id !== "check-all"
          && id !== "lang"
          && id !== "granularity"
           ) {
          languageId = id
        }
        phrases.forEach( phrase =&gt; {
          const action = (phrase.getAttribute("lang") === languageId)
            ? "add"
            : "remove"
          phrase.classList[action]("selected")
        })

        const action = (id === "en")
          ? "add"
          : "remove"
          useCSS.classList[action]("active")

        segmentText()
      }


      const target = document.querySelector("[type=radio]:checked")
      setLanguage({ target })

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>
<p>As before, you might like to open this page in a different browser
window, so that you can interact with this demo as you continue reading
this tutorial.</p>
</section>
<!-- Intl.Segmenter -->
<section id="intl-segmenter-language" aria-labelledby="intl-segmenter-language" data-item="Intl.Segmenter language">
<h2>
<a href="#intl-segmenter">Intl.Segmenter: language</a>
</h2>
<p>You‚Äôve just seen that Intl.Segmenter can detect where words begin and
end in English. <em>But</em>, you say, <em>that‚Äôs easy. There are breaks
between words when there is a space, or a punctuation mark.</em></p>
<p>‚ÄúAh!‚Äù I answer. ‚ÄúYou‚Äôre 100% sure about that? Where are the
word-endings in the phrase ‚Äòthe children‚Äôs dogs‚Äô toys‚Äô?‚Äù</p>
<p>And what about languages like Japanese, Korean and Thai, where spaces
are not used between words? Or languages like Arabic, which use
different letter forms for the same letters if it appears at the start,
in the middle, or at the end of a word?</p>
<h3 id="more">More</h3>
<p>If you click on the word <code>&gt; More</code> in the demo you‚Äôve
just seen, you can explore examples in 12 different languages. Most of
the sentences in the demo are taken from the Wikipedia article about the
language or the country in the given language. Here‚Äôs how a sentence in
Japanese is segmented into words:</p>
<figure>
<img src="images/japanese.webp"
alt="Splitting text into words in Japanese" />
<figcaption aria-hidden="true">Splitting text into words in
Japanese</figcaption>
</figure>
<p>You‚Äôve already seen that that you need to tell the Intl.Segmenter
what language you want to segment, as well as what <em>granularity</em>
you want. Something like this:</p>
<pre class="language-js"><code class="language-js">const lang = "en";
const options = { granularity: "word" };
const segmenter = new Intl.Segmenter(lang, options);</code></pre>
<p>You may be surprised (I certainly was), that choosing
<code>"en"</code> for segmenting Japanese text seems to work rather
well. Indeed, the results do not look very different from what you get
if you choose ‚Äúja‚Äù as the language code for segmenting Japanese
text:</p>
<figure>
<img src="images/japanese_with_ja.webp"
alt="Using ‚Äúja‚Äù to split Japanese text into words" />
<figcaption aria-hidden="true">Using ‚Äúja‚Äù to split Japanese text into
words</figcaption>
</figure>
<h3 id="identical-results-across-language-settings">Identical results
across language settings</h3>
<p>Indeed, just to make sure that I wasn‚Äôt missing something subtle, I
added a test in my demo, to segment the text of any chosen language
using a segmenter set to use <em>every other language</em>, and found
that the results in all cases are identical. Check the Compare
Segmentation Across All Languages checkbox to run this test for
whichever language you choose.</p>
<figure>
<img src="images/identical.webp"
alt="Using ‚Äúja‚Äù to split Japanese text into words" />
<figcaption aria-hidden="true">Using ‚Äúja‚Äù to split Japanese text into
words</figcaption>
</figure>
<p>The segmentation results for all the languages in this demo are
always identical, regardless of the language that the Intl.Segmenter
instance is told to expect. Click below to see the test that I
wrote.</p>
<details class="tldr">
<summary>
Testing segmentation with Segmenters in all languages
</summary>
<p>You can find the full text of the HTML page at <a
href="https://github.com/MERNCraft/Intl-Segmenter">GitHub
repository</a>.</p>
<pre class="language-js line-numbers" data-start="318"><code class="language-js line-numbers">      function checkAllLanguageSettings(text) {
        // Segment the current text using all values of lang
        const sets = langs.map( lang =&gt; {
          const options = { granularity: granularity.value }
          const segmenter = new Intl.Segmenter(lang, options)
          const segments = Array.from(segmenter.segment(text))
          segments.lang = lang

          return segments
        })

        // Pair each segmentation with one from a different lang
        const pairs = sets.reduce(( pairs, original, index) =&gt; {
          const compare =  (index)
            ? sets[index - 1]
            : sets[sets.length - 1]

            pairs.push([ original, compare ])
          return pairs
        }, [])

        // If every pair contains identical segmentations, then
        // all the segmentations are identical.
        const same = pairs.every(([ original, compare ]) =&gt; (
          JSON.stringify(original) === JSON.stringify(compare)
        ))

        identical.innerHTML = `Segmentation results with all language settings are: <b>${same ? "identical" : "different"}</b>`
      }</code></pre>
</details>
<details class="note" open>
<summary>
More to come?
</summary>
<p>The <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter/Segmenter#parameters">MDN
documentation</a> indicates that this parameter is
<em>optional</em>.</p>
<p>Perhaps this is a sign that Intl.Segmenter is able to recognize what
segmentation rules to apply based on the character codes usend in the
text being segmented‚Ä¶ in which case it is already doing an excellent
job, and no language setting is unnecessary.</p>
<p>Perhaps the language setting has been included now to allow for more
fine-tuned segmentation in the future. In this case, it would make make
sense to <strong>provide the correct language setting</strong>, so that
your code can profit from better segmentation in future browsers.</p>
</details>
</section>
<!-- Intl.Segmenter granularity -->
<!-- Graphemes -->
<section id="graphemes" aria-labelledby="graphemes" data-item="Graphemes">
<h2>
<a href="#graphemes">Graphemes</a>
</h2>
<p>The <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter/Segmenter#parameters">second
parameter</a> that you can use when you create a new Intl.Segmenter
instance is an object, which allows you to define the
<em>granularity</em> and a <em>localeMatcher</em>.</p>
<details class="pivot" open>
<summary>
Further reading
</summary>
<p>I won‚Äôt treat <em>localeMatcher</em> here, but you can find more
information about this in <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locale_identification_and_negotiation">the
entry for Intl on the MDN web site</a>.</p>
</details>
<h3 id="what-is-a-grapheme">What is a <code>grapheme</code>?</h3>
<p>A grapheme is not a letter, and it is not a Unicode code point. It is
a visual representation of something meaningful.</p>
<p>Here are three emojis:</p>
<p style="font-size: 5em; text-align: center">
üåòüêàüêà‚Äç‚¨õ
</p>
<p>(You could imagine that this means: ‚ÄúAt night, all cats are
grey.‚Äù)</p>
<p>Each emoji is a grapheme. Try this:</p>
<ol type="1">
<li>Copy the moon and cats emojis</li>
<li>Open the Console in your browser</li>
<li>Type <code>e = "üåòüêàüêà‚Äç‚¨õ"</code></li>
<li>Type <code>s = new Intl.Segmenter()</code> (Note that, by default,
Intl.Segmenter uses ‚Äúgrapheme‚Äù for its granularity.)</li>
<li>Type <code>Array.from(s.segment(e))</code> (I‚Äôll explain the
<code>Array.from()</code> in a moment.)</li>
</ol>
<p>You will probably see something like this:</p>
<figure>
<img src="images/cats.webp"
alt="A tabby cat and a black cat become two tabby cats and a black square" />
<figcaption aria-hidden="true">A tabby cat and a black cat become two
tabby cats and a black square</figcaption>
</figure>
<ol start="6" type="1">
<li>Now type this: <code>e.split("")</code></li>
</ol>
<p>Here‚Äôs the output I get:</p>
<pre class="node line-numbers"><code class="node line-numbers">[ '\ud83c', '\udf18', '\ud83d', '\udc08', '\ud83d', '\udc08', '‚Äç', '‚¨õ' ]</code></pre>
<h3 id="surrogate-characters">Surrogate characters</h3>
<p>Unicode uses <code>UTF-16</code>, which uses the numbers
<code>0</code> to <code>2^16 - 1</code> (65535). That‚Äôs 65536 numbers,
but Chinese has over 70000 characters all of its own.</p>
<p>To create extra place to which to assign all the different symbols
that humans currently communicate with, Unicode uses a trick <a
href="https://www.johndcook.com/blog/2025/03/09/unicode-surrogates/">described
in detail here</a>. In short, it defines a set of high-value 16-bit
numbers as <em>surrogates</em>, and decides that these numbers <em>on
their own</em> have no meaning, but <em>when used in pairs</em> take on
a specific meaning.</p>
<p>In your browser console, try:</p>
<ol start="7" type="1">
<li><code>[ '\ud83c', '\udf18' ].join("")</code></li>
</ol>
<p>Do you see a crescent moon? But <code>'\ud83c'</code> on its own, is
just an echo of itself.</p>
<p>For fun, try:</p>
<ol start="8" type="1">
<li><code>[ '\ud83c', '\udf17' ].join("")</code></li>
</ol>
<p>Do you see the moon in its third quarter?</p>
<p>And a longer sequence like‚Ä¶</p>
<ol start="9" type="1">
<li><code>[ '\ud83d', '\udc08', '‚Äç', '‚¨õ' ].join("")</code></li>
</ol>
<p>‚Ä¶ can produce a cat-which-is-black in your browser page.</p>
<details class="note" open>
<summary>
Zero-Width Joiner (ZWJ)
</summary>
<p>Note that the character <code>'‚Äç'</code> in the array above is not an
empty string. It‚Äôs a <a
href="https://en.wikipedia.org/wiki/Zero-width_joiner">zero-width
joiner</a>, and it‚Äôs used to indicate that two separate characters
should be treated as one.</p>
<p>When writing in Hindi, for instance, this sequence‚Ä¶</p>
<blockquote>
<p>[ka <code>‡§ï</code>] [virƒÅma ‡•ç] [ZWJ] [·π£a <code>‡§∑</code>]</p>
</blockquote>
<p>‚Ä¶ is interpreted as this single character:</p>
<blockquote>
<p><code>‡§ï‡•ç‚Äç‡§∑</code></p>
</blockquote>
<p>In the black cat emoji, the zero-width joiner is used to indicate
that the cat emoji and the black colour character should be combined to
make a single black cat grapheme.</p>
<p>Here‚Äôs how you can see that <code>'‚Äç'</code> is not an <em>empty</em>
string, and that the black square character is a string like any
other.</p>
<pre class="node line-numbers"><code class="node line-numbers">&gt; '‚Äç'.charCodeAt(0)
8205
&gt; '‚¨õ'.charCodeAt(0)
11035</code></pre>
</details>
<h3 id="non-emoji-multiple-character-graphemes">Non-emoji
multiple-character graphemes</h3>
<p>You‚Äôve seen that a black cat is defined as four different Unicode
code points. The same technique is applied to create a single grapheme
from separate characters in many languages. Here, for example is how the
first word of a sentence in Tamil (translation: ‚ÄúI am going to school.‚Äù)
is segmented into graphemes by Intl.Segmenter:</p>
<figure>
<img src="images/tamil.webp"
alt="A Tamil sentence segmented into graphemes" />
<figcaption aria-hidden="true">A Tamil sentence segmented into
graphemes</figcaption>
</figure>
<p>At first glance, you might think that the first word (pronounced
‚ÄúNƒÅ·πâ‚Äù) is made of three or maybe four characters, but Intl.Segmenter
knows that these should be combined to form only two graphemes.</p>
<figure>
<img src="images/tamil_word.webp"
alt="The first word has two letters; the first letter (NƒÅ) is in two parts" />
<figcaption aria-hidden="true">The first word has two letters; the first
letter (NƒÅ) is in two parts</figcaption>
</figure>
<p>If you use the standard JavaScript <code>.split</code> String method,
you will indeed see four characters‚Ä¶</p>
<pre class="node line-numbers"><code class="node line-numbers">&gt; "‡Æ®‡Ææ‡Æ©‡Øç".split("")
[ '‡Æ®', '‡Ææ', '‡Æ©', '‡Øç' ]</code></pre>
<p>‚Ä¶ but Intl.Segmenter combines them the way a native Tamil speaker
would:</p>
<pre class="node line-numbers"><code class="node line-numbers">&gt; Array.from(s.segment("‡Æ®‡Ææ‡Æ©‡Øç"))
[
  { segment: '‡Æ®‡Ææ', index: 0, input: '‡Æ®‡Ææ‡Æ©‡Øç' },
  { segment: '‡Æ©‡Øç', index: 2, input: '‡Æ®‡Ææ‡Æ©‡Øç' }
]</code></pre>
<p>If you are not a native Tamil speaker, it‚Äôs good to be able to trust
Intl.Segmenter to help you understand what to do. And the advantage is
that Intl.Segmenter provides this help for many many languages,
including the ones that you already master, so you have one ready-made
solution that you can use and re-use.</p>
</section>
<!-- Intl.Segmenter output -->
<section id="intl-segmenter-segment" aria-labelledby="intl-segmenter-segment" data-item="The Segment Object">
<h2>
<a href="#intl-segmenter-segment">The Segment Object</a>
</h2>
<p>I promised that I would explain why I have been using
<code>Array.from()</code>.</p>
<p>Here‚Äôs what happens when I create a segmenter in Node.js or a browser
console. (Note that I don‚Äôt use <code>let</code> or <code>const</code>,
which means that the variables I create are global
<code>var</code>s.)</p>
<pre class="language-js"><code class="language-js">&gt; segmenter = new Intl.Segmenter("en", { granularity: "word" })
Segmenter [Intl.Segmenter] {}
&gt; segmenter.resolvedOptions()
{ locale: 'en', granularity: 'word' }</code></pre>
<p>Here‚Äôs what I get when I use its <code>segment()</code> method:</p>
<pre class="language-js"><code class="language-js">&gt; output = segmenter.segment("Hello world!")
{}</code></pre>
<p>The console tells me that this is an object, but it does not give me
any more details. But I can use <code>Array.from()</code> to generate an
array from whatever this object holds:</p>
<pre class="language-js"><code class="language-js">&gt; Array.from(output)
[
  {
    segment: 'Hello',
    index: 0,
    input: 'Hello world!',
    isWordLike: true
  },
  { segment: ' ',
    index: 5,
    input: 'Hello world!',
    isWordLike: false
  },
  {
    segment: 'world',
    index: 6,
    input: 'Hello world!',
    isWordLike: true
  },
  { segment: '!',
    index: 11,
    input: 'Hello world!',
    isWordLike: false     
  }
]</code></pre>
<p>I‚Äôll discuss the structure of the objects inside the
<code>output</code> in the next section. First I‚Äôll explain what kind of
object <code>output</code> is, and what advantages there are for
creating such an object.</p>
<h3 id="segment-returns-an-iterable"><code>segment()</code> returns an
<em>iterable</em></h3>
<p>The output of the <code>new Intl.Segmenter().segment()</code> object
is a <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter/segment/Segments">Segment</a>
<a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators#iterables">iterable</a>.
This means that you can use a <code>for ( x of y ) { ... }</code> loop
to iterate through it, just like you can with an array:</p>
<pre class="language-js wrap"><code class="language-js wrap">&gt; for ( item of output ) { console.log(item) }
{ segment: 'Hello', index: 0, input: 'Hello world!', isWordLike: true }
{ segment: ' ', index: 5, input: 'Hello world!', isWordLike: false }
{ segment: 'world', index: 6, input: 'Hello world!', isWordLike: true }
{ segment: '!', index: 11, input: 'Hello world!', isWordLike: false }</code></pre>
<details class="tip">
<summary>
Tip: use an Iterator object
</summary>
<p>You can also retrieve its <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators#iterators">iterator
object</a>, and use that to step through its items:</p>
<pre class="language-javascript wrap"><code class="language-javascript wrap">&gt; iterator = output[Symbol.iterator]()
Object [Segmenter String Iterator] {}
&gt; iterator.next()
{
  value: {
    segment: 'Hello',
    index: 0,
    input: 'Hello world!',
    isWordLike: true
  },
  done: false
}
&gt; iterator.next()
{
  value: { segment: ' ', index: 5, input: 'Hello world!', isWordLike: false },
  done: false
}
&gt; iterator.next()
{
  value: {
    segment: 'world',
    index: 6,
    input: 'Hello world!',
    isWordLike: true
  },
  done: false
}
&gt; iterator.next()
{
  value: { segment: '!', index: 11, input: 'Hello world!', isWordLike: false },
  done: false
}
&gt; iterator.next()
{ value: undefined, done: true }</code></pre>
</details>
<h3 id="output.containing"><code>output.containing()</code></h3>
<p>You can use <code>for ... of</code> loops with Arrays, Strings, Maps
and Sets. You can also use an Iterator object (as described above) with
these data types. Each type of object provides its own special set of
functions, like <code>Array.filter()</code> or
<code>Set.has()</code></p>
<p>One feature that is unique to the Segment iterable is the
<code>containing()</code> method. This accepts an integer index value as
its argument, and returns the item which contains a grapheme at that
index position:</p>
<pre class="language-js wrap"><code class="language-js wrap">&gt; output.containing(7)
{ segment: 'world', index: 6, input: 'Hello world!', isWordLike: true }</code></pre>
<details class="note" open>
<summary>
Segments contain a range of index values
</summary>
<p>Segment iterables are the only iterable whose items can represent an
array of index values. In the current example, the word ‚Äúworld‚Äù starts
at index 6, and continues to index 10 inclusive. This means that you can
use <code>Segment.containing()</code> to find which particular grapheme,
word or sentence contains a particular index value.</p>
</details>
</section>
<!-- Intl.Segmenter output -->
<section id="intl-segmenter-format" aria-labelledby="intl-segmenter-format" data-item="Segment Format">
<h2>
<a href="#intl-segmenter-output">Segment Format</a>
</h2>
<p>When you first met the Intl.Segmenter, you saw what it the output of
its <code>segment()</code> method is, when the <code>granularity</code>
is set to <code>"word"</code>:</p>
<pre class="language-js"><code class="language-js">[
  {
    "segment": "The",
    "index": 0,
    "input": "The irregular program mess ends now.",
    "isWordLike": true
  },
  {
    "segment": " ",
    "index": 3,
    "input": "The irregular program mess ends now.",
    "isWordLike": false
  }, ...
]</code></pre>
<p>Each consecutive object contains four property/value pairs:</p>
<ol type="1">
<li><code>"segment"</code>: a string (in this case, a whole word)</li>
<li><code>"index"</code>: a non-negative number, indicating where the
segment string starts in the text that was segmented</li>
<li><code>"input"</code>: the entire text that was segmented</li>
</ol>
<p>And, only when the options argument is
<code>{ granularity: "word" }</code>:</p>
<ol start="4" type="1">
<li><strong><code>"isWordLike"</code></strong>: <code>true</code> or
<code>false</code>, depending on whether <code>"segment"</code>
represents a word (<code>true</code>) or a non-word character like white
space or a punctuation mark (<code>false</code>).</li>
</ol>
<h3
id="granularity-grapheme"><code>{ granularity: "grapheme" }</code></h3>
<p>The <code>"isWordLike"</code> property is not included in items
generated with <code>{ granularity: "grapheme" }</code>, because there
are no words: each <code>"segment"</code> is exactly one grapheme
long.</p>
<p>As you have already seen with emojis and Tamil, a grapheme can
contain several code points, so the <code>"index"</code> of the
following item might increase by more than one. If you look back at the
<a href="#counting-units">Counting Units</a> section, you‚Äôll see that
<code>"index"</code> here refers to the same <code>UTF-16 units</code>
that the <code>Range</code> object‚Äôs <code>startOffset</code> and
<code>endOffset</code> counts.</p>
<pre class="language-js"><code class="language-js">[
  {
    "segment": "T",
    "index": 0,
    "input": "The irregular program mess ends now."
  },
  {
    "segment": "h",
    "index": 1,
    "input": "The irregular program mess ends now."
  },
  {
    "segment": "e",
    "index": 2,
    "input": "The irregular program mess ends now."
  },
  {
    "segment": " ",
    "index": 3,
    "input": "The irregular program mess ends now."
  }, ...
]</code></pre>
<h3
id="granularity-sentence"><code>{ granularity: "sentence" }</code></h3>
<p>Unlike with <code>{ granularity: "words" }</code>, you will only find
individual graphemes when <code>{ granularity: "sentence" }</code>, if
you use an unconventional writing style:</p>
<p>In the example below, both the singular opening parenthesis
characters <code>)</code> are treated as the first character in a
sentence. This leads to the last ‚Äúsentence‚Äù being an opening parenthesis
character <code>)</code> all on its own.</p>
<pre class="node"><code class="node">&gt; segmenter = new Intl.Segmenter("en", { granularity: "sentence" })
Segmenter [Intl.Segmenter] {}
&gt; Array.from(segmenter.segment("Don't worry! Be happy!  )")) 
[
  {
    segment: "Don't worry! ",
    index: 0,
    input: "Don't worry! Be happy!  )"
  },
  {
    segment: 'Be happy!  ',
    index: 13,
    input: "Don't worry! Be happy!  )"
  },
  { segment: ')', index: 24, input: "Don't worry! Be happy!  )" }
]</code></pre>
<p>In other words, this last individual character is not a separate
grapheme: it is a sentence of its own.</p>
<p>The spaces that follow after a sentence are all included as part of
that sentence. There are no separate entries for spaces like there are
with <code>{ granularity: "words" }</code>.</p>
</section>
<!-- Selections and Segments -->
<section id="selections-and-segments" aria-labelledby="selections-and-segments" data-item="Selections + Segments">
<h2>
<a href="#selections-and-segments">Selections and Segments</a>
</h2>
<p>If you now have a clear mental image of what both the Selection
object and the Segment object are, and what they can do, then you should
be ready to get them to work together.</p>
</section>
<style>
  code u,
  code u * {
    background-color: #368 !important;
    filter: brightness(1);
  }
</style>
<section id="intro" aria-labelledby="intro" data-item="Introduction">
<h2>
<a href="#intro">Introduction</a>
</h2>
<iframe id="demo" title="demo" width="600" height="300" src="https://merncraft.github.io/SplitSpansDemo/">
</iframe>
<h3 id="whats-in-store-for-you">What‚Äôs in Store for You</h3>
<h4 id="part-1-selection">Part 1: Selection</h4>
<ol type="1">
<li>window.getSelection()</li>
</ol>
<ul>
<li>What it returns (a Selection object)</li>
<li>Multiple ranges? (selection.rangeCount)</li>
<li>Basic usage examples (toString(), getRangeAt(0))</li>
</ul>
<ol start="2" type="1">
<li>The Range object</li>
</ol>
<ul>
<li>Properties: startContainer, startOffset, endContainer, endOffset,
commonAncestorContainer</li>
<li>Methods: selectNode, selectNodeContents, setStart, setEnd,
cloneRange</li>
<li>Why you often want a Range instead of just the selection string</li>
</ul>
<ol start="3" type="1">
<li>Text nodes vs element nodes</li>
</ol>
<ul>
<li>What a text node is (nodeType === 3)</li>
<li>How inline elements affect selections (<code>&lt;b&gt;</code>,
<code>&lt;i&gt;</code>, <code>&lt;span&gt;</code>)</li>
<li>Why startContainer can be a text node or an element (Safari
quirk)</li>
<li>Using childNodes to inspect the DOM structure</li>
</ul>
<ol start="4" type="1">
<li>Selection offsets</li>
</ol>
<ul>
<li>Offsets relative to the container (text node vs element)</li>
<li>Why startOffset and endOffset may not correspond to visible
characters exactly (whitespace, hidden nodes, zero-length nodes)</li>
<li>Common mistakes when computing offsets directly
<ul>
<li>Treating offsets as global visible positions</li>
<li>Assuming containers are always text nodes</li>
<li>Forgetting that whitespace rules affect selectable characters</li>
<li>Not accounting for invisible/empty text nodes</li>
<li>Treating endOffset as inclusive</li>
<li>Misunderstanding UTF-16 vs grapheme clusters</li>
<li>Using textContent.length as if spans were one node</li>
<li>Misinterpreting backwards selections</li>
<li>Mutating the DOM before preserving Range info</li>
</ul></li>
</ul>
<ol start="5" type="1">
<li>Browser differences</li>
</ol>
<ul>
<li>Safari quirks:</li>
<li>startContainer may be in a previous element‚Äôs text node</li>
<li>Selections may ‚Äúsnap‚Äù across inline boundaries</li>
<li>Chrome/Firefox generally behave consistently</li>
<li>Implications for algorithms that rely on DOM offsets</li>
</ul>
<ol start="6" type="1">
<li>Clamping / normalizing selections</li>
</ol>
<ul>
<li>Concept: adjusting startContainer and endContainer to the
‚Äúfirst/last selectable text node‚Äù in the intended range</li>
<li>Why this is needed before doing any text manipulation or
word-boundary expansion</li>
<li>Example: ‚ÄúSnap selection start to 0 offset of first text node inside
element‚Äù</li>
</ul>
<ol start="7" type="1">
<li>Traversing selected text</li>
</ol>
<ul>
<li>Why you need to iterate all text nodes between startContainer and
endContainer</li>
<li>Introduce TreeWalker or NodeIterator for walking the DOM</li>
<li>Differences between childNodes iteration vs TreeWalker (nested
inline elements)</li>
</ul>
<ol start="9" type="1">
<li>Handling whitespace white-space CSS affects what is visually
selectable</li>
</ol>
<ul>
<li>pre-wrap vs normal vs nowrap</li>
<li>How this affects offset calculations</li>
<li>Note: pseudo-elements (::before, ::after) are ignored because they
aren‚Äôt selectable</li>
</ul>
<ol start="9" type="1">
<li>Edge cases and best practices</li>
</ol>
<ul>
<li>Empty elements or elements with no text nodes</li>
<li>Nested inline elements (<b><i>text</i></b>)</li>
<li>Collapsed nodes or nodes with only whitespace</li>
<li>Using Range.compareBoundaryPoints to detect containment</li>
</ul>
<ol start="10" type="1">
<li>Topics to explore further</li>
</ol>
<ul>
<li>Using range.getClientRects() for visual selection bounds</li>
<li>Multi-range selections (rare, but good to mention)</li>
<li>How selection APIs interact with contenteditable areas</li>
<li>Selection normalization strategies from popular editors
(ProseMirror, Slate)</li>
</ul>
<h4 id="part-2-detecting-word-boundaries">Part 2: Detecting word
boundaries</h4>
<ol type="1">
<li>How browser understand word boundaries</li>
<li>Intl.Segmenter basics</li>
<li>Mapping segmenter offsets back to the DOM</li>
<li>Working no-break characters</li>
<li>Language-specific rules for punctuation</li>
<li>Boundaries around inline formatting</li>
<li>Identifying blocks that should not be broken</li>
<li>Words that span DOM nodes, for whatever reason</li>
<li>Special case: Speaker change em-dash for subtitles</li>
</ol>
<h4 id="part-3-splitting-and-merging-elements">Part 3: Splitting and
merging elements</h4>
<ol type="1">
<li>How Range mutations work</li>
<li>Splitting text nodes and inline structures</li>
<li>Extracting content with extractContents()</li>
<li>Safe merging: style checks, tagName checks</li>
<li>Wrapping selection in spans</li>
<li>Avoiding nested span hell</li>
<li>Removing/redesigning wrappers</li>
<li>Adding a class to new spans</li>
</ol>
<h4 id="mini-projects">Mini Projects</h4>
<ul>
<li><p>Project 1: Basic selection Single text node, no formatting Goal:
get selected text and offsets</p></li>
<li><p>Project 2: Inline formatting <code>&lt;b&gt;</code> or
<code>&lt;i&gt;</code> inside text Goal: understand startContainer and
endContainer with nested tags</p></li>
<li><p>Project 3: Multi-span selection Two adjacent
<code>&lt;span&gt;</code> elements Goal: see how selection crosses
elements, offsets are computed</p></li>
<li><p>Project 4: Whitespace handling Show white-space: pre-wrap vs
normal Goal: see which characters are actually selectable</p></li>
</ul>
<p>Project 5: Safari quirk Cross-span startContainer issue Goal:
understand why clamping/normalization is needed</p>
<ul>
<li><p>Project 6: Introduction to TreeWalker Walk selected text nodes,
accumulate text Goal: show how to reliably collect selected
text</p></li>
<li><p>Project 7: Selection clamping Normalize selection start/end to
first/last text node Goal: ready for word-boundary expansion in Part
2</p></li>
</ul>
<hr />
<ul>
<li>Whole-word expansion</li>
<li>Splitting text out of existing spans</li>
<li>Splitting <code>&lt;b&gt;</code>, <code>&lt;i&gt;</code>, etc. at
selection boundaries</li>
<li>Creating a new span exactly around the selection</li>
<li>Merging neighboring spans when appropriate</li>
<li>Normalizing Safari‚Äôs misaligned selection containers</li>
<li>DOM text walking</li>
<li>Range manipulation</li>
</ul>
<details class="tldr">
<summary>
TL;DR: My personal use case
</summary>
<p>I teach English as a foreign language to adults. I have friends who
teach their own native languages, to adults and to children. A big
question that we have is: ‚ÄúHow to make learners want to spend time
practising their new language?‚Äù One way is to get them to watch films in
their target language. Or perhaps better yet (and free): get them to
watch short YouTube videos on subjects that interest them.</p>
<h3 id="youtube-auto-generated-transcripts">YouTube auto-generated
transcripts</h3>
<p>Many YouTube videos provide subtitles, and an interactive transcript.
You can show the subtitles by clicking on the
<code>Subtitles/closed caption</code> button in the YouTube toolbar, and
you can show the transcript by ‚Ä¶</p>
<ul>
<li>Clicking on the <code>more...</code> button in the summary</li>
<li>Scrolling to near the end to find the <code>Show Transcript</code>
button</li>
<li>Making your web page wide enough to see the interactive transcript
to the side of your video.</li>
</ul>
<p>But the YouTube website is design for YouTube to optimize revenue.
Our language students don‚Äôt need all the ads and links and extra
content. They really just want a good video to watch, and help with
understanding what is being said.</p>
<p>Auto-generated subtitles can be wildly wrong and confusing. Even when
they are accurate, the timing of the subtitles can be awkward and
imprecise. A subtitle might contain speech both before and after a scene
change, and it might be too long to be comfortable. The transcript is
broken up into timed chunks that might not correspond to actual
sentences.</p>
<h3 id="doing-it-better">Doing it better</h3>
<p>I wanted to create something more like the system provided by <a
href="https://www.ted.com/talks/joshua_foer_feats_of_memory_anyone_can_do/transcript">ted.com</a>,
which:</p>
<ul>
<li>Shows the transcript in natural paragraphs</li>
<li>Uses a separate span for each natural break in the speech</li>
<li>Provides transcripts created by humans and translated by humans into
many different languages.</li>
</ul>
<p>I also wanted to add a feature that allows language learners to play
a particular phrase or sentence in a loop, perhaps a little more slowly,
so that they have the chance to hear how the speaker actually pronounces
the words.</p>
<p>A subtitle might say: ‚ÄúIt‚Äôs going to be good!‚Äù but the speaker might
make a sound like ‚ÄúSgonnbegooh!‚Äù It can take a learner a little time to
get used to the shortcuts native speakers make, that other native
speakers can easily understand.</p>
<p>So, before releasing my ‚ÄúLearn a language through YouTube‚Äù app, I had
to make myself a tool that would allow me to:</p>
<ul>
<li>Paste a YouTube URL</li>
<li>Automatically download the transcript</li>
<li>Automatically download the audio file, and generate a waveform
graphic from it, so I could easily see where sounds began and ended</li>
<li>Edit the text of the auto-generated transcript</li>
<li>Divide the transcript into natural segments for subtitles</li>
<li>Set the start and end times of each subtitle precisely</li>
<li>Allow a translator to follow the video and the original subtitles
while making a translation</li>
<li>Provide the translator with some flexibility about subtitle timing,
as different languages give the same information in a different
order.</li>
<li>Export the subtitles in the standard SRT format, to be used by my
‚ÄúLearn a language through YouTube‚Äù app.</li>
</ul>
<p>Hence the need to split and merge the text of HTML spans, as
described in this tutorial.</p>
<p>You can find the Subtitle Optimizer tool <a href="">here</a>, and the
‚ÄúLearn a language through YouTube‚Äù app <a
href="https://stv.jazyx.com">here</a>.</p>
<blockquote>
<h3 id="fun-fact">Fun Fact</h3>
<p>One advantage of watching YouTube videos embedded in third-party site
is that <strong>the videos are never interrupted by ads</strong>.</p>
<p>And yes, I contact the content creators whose videos I link to, to
make sure that they are happy that their work is used in this
educational manner, even if it means that they don‚Äôt earn any ad revenue
from it.</p>
</blockquote>
</details>
</section>

<div class="spacer"></div>
<footer id="content-footer">
<button type="button" class="previous" disabled>
  <img src="../public/svg/prev.svg" alt="prev" draggable="false">
</button>
<span class="previous-name"></span>
<span class="spacer"></span>
<button type="button" class="next">
  <img src="../public/svg/next.svg" alt="next" draggable="false">
</button>
<span class="next-name"></span>
</footer>
</main>

<nav
id="menu"
aria-labelledby="menu"
class="open"
>
<div class="theme">
  <label
  title="Dark"
  >
  <img src="../public/svg/dark.svg" alt="dark">
  <input
  type="radio"
  name="theme"
  id="theme-dark"
  checked
  >
  </label>
  <label
  title="Light"
  >
  <img src="../public/svg/light.svg" alt="light">
  <input
  type="radio"
  name="theme"
  id="theme-light"
  >
  </label>
  </div>
  <div class="paging">
  <label
  title="Split into sections"
  >
  <img src="../public/svg/pages.svg" alt="pages">
  <input
  type="radio"
  name="paging"
  id="pages"
  checked
  >
  </label>
  <label
  title="Show as a single page"
  >
  <img src="../public/svg/scroll.svg" alt="scroll">
  <input
  type="radio"
  name="paging"
  id="scroll"
  >
  </label>
  </div>
<img src="../public/svg/hamburger.svg" alt="menu" id="menu-icon">

<ul id="menu-items">
</ul>
<div id="repo">
<a
href="https://github.com/MERNCraft/SplitSpans/issues/new"
>
Feedback
</a>

<a
class="repo"
href="https://github.com/MERNCraft/SplitSpans"
>
<img src="../public/svg/github.svg" alt="github logo">
<span>GitHub repository</span>
</a>
</div>
</nav>
</body>
</html>